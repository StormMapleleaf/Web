<map version="freeplane 1.11.5">
<!--To view this file, download free mind mapping software Freeplane from https://www.freeplane.org -->
<node TEXT="JavaScript" LOCALIZED_STYLE_REF="AutomaticLayout.level.root" FOLDED="false" ID="ID_1090958577" CREATED="1409300609620" MODIFIED="1687642579401" VGAP_QUANTITY="3 pt"><hook NAME="MapStyle" background="#d6e8e8" zoom="1.074">
    <properties show_icon_for_attributes="true" edgeColorConfiguration="#808080ff,#ff0000ff,#0000ffff,#00ff00ff,#ff00ffff,#00ffffff,#7c0000ff,#00007cff,#007c00ff,#7c007cff,#007c7cff,#7c7c00ff" show_note_icons="true" associatedTemplateLocation="template:/light_sky_element_template.mm" fit_to_viewport="false"/>

<map_styles>
<stylenode LOCALIZED_TEXT="styles.root_node" STYLE="oval" UNIFORM_SHAPE="true" VGAP_QUANTITY="24 pt">
<font SIZE="24"/>
<stylenode LOCALIZED_TEXT="styles.predefined" POSITION="bottom_or_right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="default" ID="ID_4172522" ICON_SIZE="12 pt" FORMAT_AS_HYPERLINK="false" COLOR="#051552" BACKGROUND_COLOR="#5cd5e8" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="8 pt" SHAPE_VERTICAL_MARGIN="5 pt" BORDER_WIDTH_LIKE_EDGE="false" BORDER_WIDTH="1.7 px" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#1164b0" BORDER_DASH_LIKE_EDGE="true" BORDER_DASH="SOLID" VGAP_QUANTITY="3 pt">
<arrowlink SHAPE="CUBIC_CURVE" COLOR="#000000" WIDTH="2" TRANSPARENCY="200" DASH="" FONT_SIZE="9" FONT_FAMILY="SansSerif" DESTINATION="ID_4172522" STARTINCLINATION="116.25 pt;0 pt;" ENDINCLINATION="116.25 pt;28.5 pt;" STARTARROW="NONE" ENDARROW="DEFAULT"/>
<font NAME="SansSerif" SIZE="10" BOLD="false" STRIKETHROUGH="false" ITALIC="false"/>
<edge STYLE="bezier" COLOR="#051552" WIDTH="2" DASH="SOLID"/>
<richcontent TYPE="DETAILS" CONTENT-TYPE="plain/auto"/>
<richcontent TYPE="NOTE" CONTENT-TYPE="plain/auto"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.details" COLOR="#fff024" BACKGROUND_COLOR="#000000"/>
<stylenode LOCALIZED_TEXT="defaultstyle.attributes">
<font SIZE="9"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.note" COLOR="#000000" BACKGROUND_COLOR="#f6f9a1" TEXT_ALIGN="LEFT">
<icon BUILTIN="clock2"/>
<font SIZE="10" ITALIC="true"/>
<edge COLOR="#000000"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.floating">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.selection" COLOR="#ffffff" BACKGROUND_COLOR="#cc7212" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#1164b0"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.user-defined" POSITION="bottom_or_right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="styles.important" ID="ID_1823054225" COLOR="#fff024" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#9d5e19">
<icon BUILTIN="yes"/>
<arrowlink COLOR="#9d5e19" TRANSPARENCY="255" DESTINATION="ID_1823054225"/>
<font SIZE="11" BOLD="true"/>
<edge COLOR="#9d5e19"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.AutomaticLayout" POSITION="bottom_or_right" STYLE="bubble">
<stylenode LOCALIZED_TEXT="AutomaticLayout.level.root" COLOR="#ffffff" BACKGROUND_COLOR="#053d8b" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="10 pt" SHAPE_VERTICAL_MARGIN="10 pt" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#2c2b29" BORDER_DASH_LIKE_EDGE="true">
<font SIZE="18"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,1" COLOR="#ffffff" BACKGROUND_COLOR="#1164b0" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="8 pt" SHAPE_VERTICAL_MARGIN="5 pt" BORDER_COLOR="#2c2b29">
<font SIZE="16"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,2" COLOR="#ffffff" BACKGROUND_COLOR="#298bc8" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="8 pt" SHAPE_VERTICAL_MARGIN="5 pt" BORDER_COLOR_LIKE_EDGE="true" BORDER_COLOR="#f0f0f0">
<font SIZE="14"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,3" COLOR="#ffffff" BACKGROUND_COLOR="#3fb7db" STYLE="bubble" SHAPE_HORIZONTAL_MARGIN="8 pt" SHAPE_VERTICAL_MARGIN="5 pt" BORDER_COLOR_LIKE_EDGE="true" BORDER_COLOR="#f0f0f0">
<font SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,4" COLOR="#051552" BACKGROUND_COLOR="#5cd5e8" BORDER_COLOR_LIKE_EDGE="true" BORDER_COLOR="#f0f0f0">
<font SIZE="11"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,5" BORDER_COLOR_LIKE_EDGE="true" BORDER_COLOR="#f0f0f0">
<font SIZE="11"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,6" BORDER_COLOR_LIKE_EDGE="true" BORDER_COLOR="#f0f0f0">
<font SIZE="10"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,7" BORDER_COLOR="#f0f0f0">
<font SIZE="10"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,8" BORDER_COLOR="#f0f0f0">
<font SIZE="10"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,9" BORDER_COLOR="#f0f0f0">
<font SIZE="10"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,10" BORDER_COLOR="#f0f0f0">
<font SIZE="9"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,11" BORDER_COLOR="#f0f0f0">
<font SIZE="9"/>
</stylenode>
</stylenode>
</stylenode>
</map_styles>
</hook>
<hook NAME="accessories/plugins/AutomaticLayout.properties" VALUE="ALL"/>
<font BOLD="true"/>
<node TEXT="变量" FOLDED="true" POSITION="bottom_or_right" ID="ID_1539428803" CREATED="1687642605628" MODIFIED="1687652665485" VGAP_QUANTITY="3 pt"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      变量，就是可以改变值的容器：
    </p>
    <p>
      用于定义变量的名字的字符称之为变量名，
    </p>
    <p>
      实际存储的内容称之为变量值
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      ECMAScript变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符
    </p>
  </body>
</html></richcontent>
<node TEXT="var关键字" FOLDED="true" ID="ID_1909172738" CREATED="1687648760417" MODIFIED="1687653345953">
<node TEXT="var message;" ID="ID_1186677557" CREATED="1687652837564" MODIFIED="1687652839032"/>
<node TEXT="var message = &quot;hi&quot;;" ID="ID_844434174" CREATED="1687652844900" MODIFIED="1687652846655"/>
<node TEXT="message = 100;  // 合法，但不推荐" ID="ID_44530427" CREATED="1687652860954" MODIFIED="1687652862417"/>
<node TEXT="var message = &quot;hi&quot;,     found = false,      age = 29;" ID="ID_913611540" CREATED="1687652886088" MODIFIED="1687652893172"/>
</node>
<node TEXT="let声明" FOLDED="true" ID="ID_1175857865" CREATED="1687648761243" MODIFIED="1687663614380" VGAP_QUANTITY="3 pt">
<node TEXT="let message;" ID="ID_1425271794" CREATED="1687653518003" MODIFIED="1687654667035"/>
<node TEXT="let message = &quot;hi&quot;;" ID="ID_1683684589" CREATED="1687653518713" MODIFIED="1687663616393"/>
<node TEXT="let message = &quot;hi&quot;,     found = false,      age = 29;" ID="ID_1923494508" CREATED="1687654690443" MODIFIED="1687654694805"/>
</node>
<node TEXT="const声明" FOLDED="true" ID="ID_139863177" CREATED="1687652678510" MODIFIED="1687663798337"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制
    </p>
  </body>
</html></richcontent>
<node TEXT="const name=&apos;加钱居士&apos;;" ID="ID_1102565737" CREATED="1687663600701" MODIFIED="1687663654458"/>
<node TEXT="const obj={&#xa;    name:&apos;加钱居士&apos;，&#xa;    sex:&apos;man&apos;,&#xa;    age:18&#xa;}" ID="ID_755169716" CREATED="1687663800572" MODIFIED="1687663869163"/>
</node>
<node TEXT="var 与let的区别" FOLDED="true" ID="ID_1694470626" CREATED="1687653742573" MODIFIED="1687653752340">
<node TEXT="let 不允许出现重复定义（包括与var）" ID="ID_1531720983" CREATED="1687653787939" MODIFIED="1687654009530"/>
<node TEXT="var 允许变量提升，let禁止变量提升" ID="ID_108811543" CREATED="1687654017670" MODIFIED="1687654028341"/>
<node TEXT="作用域" FOLDED="true" ID="ID_1362637836" CREATED="1687654041561" MODIFIED="1687654103405">
<node TEXT="let声明的范围是块作用域" POSITION="bottom_or_right" ID="ID_1048652878" CREATED="1687653754437" MODIFIED="1687653762246"/>
<node TEXT="var声明的范围是函数作用域" POSITION="bottom_or_right" ID="ID_160636889" CREATED="1687653771018" MODIFIED="1687653772481"/>
</node>
<node TEXT="全局声明" ID="ID_362083089" CREATED="1687654061531" MODIFIED="1687654073981">
<node TEXT="var变量成为window的属性" ID="ID_401896873" CREATED="1687654171039" MODIFIED="1687654190251"/>
<node TEXT="let变量不会成为window的属性" ID="ID_1397502764" CREATED="1687654194518" MODIFIED="1687654200760"/>
</node>
<node TEXT="条件声明" FOLDED="true" ID="ID_486854874" CREATED="1687654069266" MODIFIED="1687654572037"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      注意不能使用let进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。
    </p>
  </body>
</html></richcontent>
<node TEXT="var可以使用条件声明" ID="ID_664128191" CREATED="1687654408099" MODIFIED="1687654419776">
<node TEXT="        if(true){&#xa;            var age = 88;&#xa;        }&#xa;        alert(age)" ID="ID_371310372" CREATED="1687654532031" MODIFIED="1687654539250"/>
</node>
<node TEXT="let不可以使用条件声明" ID="ID_938433338" CREATED="1687654424862" MODIFIED="1687654431105">
<node TEXT="        if(true){&#xa;            let age = 88;&#xa;        }&#xa;        alert(age)" ID="ID_1117477224" CREATED="1687654527048" MODIFIED="1687654531802"/>
</node>
</node>
</node>
</node>
<node TEXT="JavaScript发展历史" POSITION="top_or_left" ID="ID_1669930941" CREATED="1687642607746" MODIFIED="1687642619192"/>
<node TEXT="数据类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_649827034" CREATED="1687642608176" MODIFIED="1687644753630">
<node TEXT="检测方式" FOLDED="true" POSITION="bottom_or_right" ID="ID_1002218488" CREATED="1687654962648" MODIFIED="1687654972727">
<node TEXT="使用typeof运算符" ID="ID_321206324" CREATED="1687654983749" MODIFIED="1687654989048">
<node TEXT="typeof 变量名" ID="ID_841414848" CREATED="1687654991075" MODIFIED="1687655012538"/>
<node TEXT="typeof(变量名)" ID="ID_720604479" CREATED="1687655013946" MODIFIED="1687655025467"/>
<node TEXT="typeof 值" ID="ID_845261122" CREATED="1687655027958" MODIFIED="1687655039095"/>
</node>
</node>
<node TEXT="数据分类" FOLDED="true" POSITION="bottom_or_right" ID="ID_1141877831" CREATED="1687654876729" MODIFIED="1687654981585">
<node TEXT="undefined类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_1051883301" CREATED="1687654750783" MODIFIED="1687654762415">
<node TEXT="值：undefined" ID="ID_1170014554" CREATED="1687655076074" MODIFIED="1687655109853"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      表示没定义过的变量
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="boolean类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_850625696" CREATED="1687654796597" MODIFIED="1687654809452">
<node TEXT="值：true" ID="ID_1495154364" CREATED="1687655112403" MODIFIED="1687655138144"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      表示真值
    </p>
  </body>
</html></richcontent>
</node>
<node TEXT="值：false" ID="ID_186054673" CREATED="1687655113024" MODIFIED="1687655149183"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      表示假值
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="string类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_1820602964" CREATED="1687654751745" MODIFIED="1687654784659">
<node TEXT="方法1：单引号声明" ID="ID_320169297" CREATED="1687655154870" MODIFIED="1687655185505">
<node TEXT="let lastName = &apos;珍香&apos;;" ID="ID_821185113" CREATED="1687655280958" MODIFIED="1687655324781"/>
</node>
<node TEXT="方法2：双引号声明" ID="ID_1097622362" CREATED="1687655155391" MODIFIED="1687655192928">
<node TEXT="let firstName = &quot;史&quot;;" ID="ID_1233198949" CREATED="1687655326846" MODIFIED="1687655346363"/>
</node>
<node TEXT="方法3：反引号声明" ID="ID_1512626742" CREATED="1687655155815" MODIFIED="1687655200771">
<node TEXT="let fullName = `熊初墨`  " ID="ID_1973789806" CREATED="1687655354198" MODIFIED="1692053185930">
<node TEXT="变量解析可以使用${变量}" ID="ID_1354436134" CREATED="1692053186467" MODIFIED="1692053202180"/>
</node>
</node>
</node>
<node TEXT="number类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_773878433" CREATED="1687654751274" MODIFIED="1687654777176">
<node TEXT="整型" ID="ID_1257221970" CREATED="1687655720878" MODIFIED="1687655751092">
<node TEXT="十进制：let num = 88;" ID="ID_1921108863" CREATED="1687657417421" MODIFIED="1687657437848"/>
<node TEXT="八进制：let num = 037" ID="ID_719485239" CREATED="1687657418019" MODIFIED="1687657470292"/>
<node TEXT="十六进制：let num = 0xA5" ID="ID_1733472969" CREATED="1687657418454" MODIFIED="1687657488181"/>
</node>
<node TEXT="浮点型" ID="ID_673083774" CREATED="1687655721401" MODIFIED="1687655754891">
<node TEXT="let price = 3.15;" ID="ID_1480147727" CREATED="1687657489942" MODIFIED="1687657508395"/>
<node TEXT="let price = 315e-2" ID="ID_1229402977" CREATED="1687657490949" MODIFIED="1687657535751"/>
</node>
<node TEXT="NaN类型" ID="ID_196942839" CREATED="1687655721834" MODIFIED="1687657671102"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      NaN的意思是not a number&#xa0;&#xa0;意思就是不是数字，一般是拿非数字运算的结果值。
    </p>
    <p>
      
    </p>
    <p>
      需要注意：NaN是为了防止报错出现的值，不要刻意获取NaN，并且NaN不等于任何数字，包括NaN本身，NaN参与运算结果都是NaN
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
  </body>
</html></richcontent>
<node TEXT="let num = NaN;" ID="ID_1055433537" CREATED="1687657545762" MODIFIED="1687657560603"/>
</node>
</node>
<node TEXT="function类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_1682329078" CREATED="1687654752091" MODIFIED="1687654816541">
<node TEXT="方法1：函数格式&#xa;function 函数名(){&#xa;&#xa;}" ID="ID_1475412315" CREATED="1687655628951" MODIFIED="1687655657705"/>
<node TEXT="方法2：使用内置对象&#xa;let 函数名 = new Function();" ID="ID_1268578743" CREATED="1687655629492" MODIFIED="1687655691838"/>
</node>
<node TEXT="object类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_853534649" CREATED="1687654752476" MODIFIED="1687657777337"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ECMAScript中的对象其实就是一组数据和功能的集合。
    </p>
  </body>
</html></richcontent>
<node TEXT="方法1：let o = new Object();" ID="ID_117737373" CREATED="1687657778717" MODIFIED="1687657791927"/>
<node TEXT="方法2：let o = {}" ID="ID_597068558" CREATED="1687657780205" MODIFIED="1687657814013"/>
</node>
<node TEXT="symbol类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_558911105" CREATED="1687654752830" MODIFIED="1687657874888"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。
    </p>
  </body>
</html></richcontent>
<node TEXT="let sym = symbol()" ID="ID_1038276278" CREATED="1687657846500" MODIFIED="1690387140489"/>
<node TEXT="let sym = symbol(&apos;go&apos;)" ID="ID_57118627" CREATED="1690387146698" MODIFIED="1690387158042"/>
<node TEXT="特点" ID="ID_1856270858" CREATED="1690387168117" MODIFIED="1690387175120">
<node TEXT="Symbol的值是唯一的，用来解决命名冲突的问题" ID="ID_539695416" CREATED="1690387175241" MODIFIED="1690387181516"/>
<node TEXT="Symbol值不能与其他数据类型进行运算" ID="ID_515443912" CREATED="1690387181610" MODIFIED="1690387196381"/>
<node TEXT="Symbol定义得的对象的属性不能使用for…in 循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名" ID="ID_1785310563" CREATED="1690387196611" MODIFIED="1690387198201"/>
<node TEXT="每次注册的symbol和symbol不相等" ID="ID_1298952989" CREATED="1690387217969" MODIFIED="1690427556276"/>
</node>
</node>
</node>
<node TEXT="数据类型转换" FOLDED="true" ID="ID_1226471461" CREATED="1687658078692" MODIFIED="1687658083797">
<node TEXT="自动转换" FOLDED="true" ID="ID_178902336" CREATED="1687658226485" MODIFIED="1687658231812">
<node TEXT="在程序运行中如果运算或者判断需要，数据可以发生自动转换类型，规则与上面一致" ID="ID_1264247398" CREATED="1687658233029" MODIFIED="1687658257433"/>
</node>
<node TEXT="强制类型转换" FOLDED="true" ID="ID_1539143444" CREATED="1690427641053" MODIFIED="1690427648211">
<node TEXT="转换为数字" FOLDED="true" POSITION="bottom_or_right" ID="ID_1549122157" CREATED="1687658086834" MODIFIED="1687658116937">
<node TEXT="方法1：Number(值)" ID="ID_1567434125" CREATED="1687658184721" MODIFIED="1687658193331"/>
<node TEXT="方法2：parseInt(值)" ID="ID_1449615362" CREATED="1687658185373" MODIFIED="1687658206181"/>
<node TEXT="方法3：parseFloat(值)" ID="ID_424686092" CREATED="1687658185934" MODIFIED="1687658216365"/>
</node>
<node TEXT="转换为字符串" FOLDED="true" POSITION="bottom_or_right" ID="ID_1858043671" CREATED="1687658086399" MODIFIED="1687658110180">
<node TEXT="方法1：值.toString()" ID="ID_1936402468" CREATED="1687658155260" MODIFIED="1687658169100"/>
<node TEXT="方法2：String(值)" ID="ID_699383673" CREATED="1687658155888" MODIFIED="1687658181464"/>
</node>
<node TEXT="转换为boolean值" POSITION="bottom_or_right" ID="ID_488506290" CREATED="1687658084913" MODIFIED="1687658104701">
<node TEXT="方法：Boolean(值)" ID="ID_1882271689" CREATED="1687658126920" MODIFIED="1687658152693"/>
</node>
</node>
</node>
</node>
<node TEXT="JavaScript组成" FOLDED="true" POSITION="top_or_left" ID="ID_1482011142" CREATED="1687642608678" MODIFIED="1687642665992">
<node TEXT="ECMAscript" FOLDED="true" ID="ID_323998445" CREATED="1687642759859" MODIFIED="1687642778881">
<node TEXT="由ECMA-262定义并提供核心功能。" ID="ID_304570434" CREATED="1687642807979" MODIFIED="1687642810071"/>
</node>
<node TEXT="文档对象模型（DOM）" ID="ID_1123014617" CREATED="1687642760382" MODIFIED="1687642786602">
<node TEXT="提供与网页内容交互的方法和接口。" ID="ID_1868540116" CREATED="1687642815025" MODIFIED="1687642819645"/>
</node>
<node TEXT="浏览器对象模型（BOM）" ID="ID_1863923350" CREATED="1687642760803" MODIFIED="1687642794043">
<node TEXT="提供与浏览器交互的方法和接口。" ID="ID_1265892435" CREATED="1687642828256" MODIFIED="1687642832501"/>
</node>
</node>
<node TEXT="运算与运算符" FOLDED="true" POSITION="bottom_or_right" ID="ID_1754484638" CREATED="1687642609102" MODIFIED="1687644763345">
<node TEXT="算数运算" FOLDED="true" ID="ID_1351088314" CREATED="1687658421573" MODIFIED="1687658644388">
<node TEXT="+ 加法运算" ID="ID_537766654" CREATED="1687658722485" MODIFIED="1687658743789"/>
<node TEXT="- 减法运算" ID="ID_1994469246" CREATED="1687658722892" MODIFIED="1687658752484"/>
<node TEXT="* 乘法运算" ID="ID_262629118" CREATED="1687658723337" MODIFIED="1687658759050"/>
<node TEXT="/ 除法运算" ID="ID_852186490" CREATED="1687658723812" MODIFIED="1687658765996"/>
<node TEXT="% 取余运算" ID="ID_671534991" CREATED="1687658724475" MODIFIED="1687658782237"/>
<node TEXT="** 指数运算" ID="ID_1729684886" CREATED="1687658724895" MODIFIED="1687658854748"/>
<node TEXT="++自增运算" ID="ID_1995320010" CREATED="1690510685536" MODIFIED="1690510706231"/>
<node TEXT="--自减运算" ID="ID_1631655833" CREATED="1690510690096" MODIFIED="1690510702329"/>
</node>
<node TEXT="赋值运算" FOLDED="true" ID="ID_224750824" CREATED="1687658422171" MODIFIED="1687658648257">
<node TEXT="。= 赋值运算" ID="ID_488384761" CREATED="1687658963181" MODIFIED="1687659016166"/>
<node TEXT="+= 加后赋值运算" ID="ID_1773752184" CREATED="1687658963604" MODIFIED="1687659039087"/>
<node TEXT="-= 减后赋值运算" ID="ID_277618013" CREATED="1687658963991" MODIFIED="1687659048476"/>
<node TEXT="*= 乘后赋值运算" ID="ID_393422858" CREATED="1687658964435" MODIFIED="1687659056756"/>
<node TEXT="/= 除后赋值运算" ID="ID_672485041" CREATED="1687659058462" MODIFIED="1687659073942"/>
<node TEXT="%= 取余后赋值运算" ID="ID_528294794" CREATED="1687659079049" MODIFIED="1687659091406"/>
<node TEXT="&gt;&gt;= 右移后赋值运算" ID="ID_844725735" CREATED="1687659096620" MODIFIED="1687659108197"/>
<node TEXT="&lt;&lt;左移后赋值运算" ID="ID_1691989378" CREATED="1687659097135" MODIFIED="1687659117461"/>
</node>
<node TEXT="关系运算" FOLDED="true" ID="ID_691546200" CREATED="1687658422827" MODIFIED="1687658626619">
<node TEXT="&gt; 大于运算" ID="ID_488583681" CREATED="1687659127321" MODIFIED="1687659135862"/>
<node TEXT="&lt; 小于运算" ID="ID_324749762" CREATED="1687659127794" MODIFIED="1687659150175"/>
<node TEXT="== 等于运算" ID="ID_1387504840" CREATED="1687659128315" MODIFIED="1687659158580"/>
<node TEXT="&gt;= 大于等于运算" ID="ID_1397329139" CREATED="1687659161385" MODIFIED="1687659169529"/>
<node TEXT="&lt;= 小于等于运算" ID="ID_591514069" CREATED="1687659170963" MODIFIED="1687659176962"/>
<node TEXT="!= 不等于运算" ID="ID_1314392467" CREATED="1687659178215" MODIFIED="1687659210607"/>
<node TEXT="=== 全等于运算" ID="ID_359187090" CREATED="1687659217195" MODIFIED="1687659222343"/>
<node TEXT="!== 不全等于运算" ID="ID_590625356" CREATED="1687659223482" MODIFIED="1687659231002"/>
</node>
<node TEXT="逻辑运算" FOLDED="true" ID="ID_1276757158" CREATED="1687658423305" MODIFIED="1687663006338" VGAP_QUANTITY="3 pt">
<node TEXT="&amp;&amp; 逻辑与运算" ID="ID_943244389" CREATED="1687659237891" MODIFIED="1687659286098">
<node TEXT="有假则假" ID="ID_802110290" CREATED="1687659302948" MODIFIED="1687659310571"/>
</node>
<node TEXT="|| 逻辑或运算" ID="ID_50414377" CREATED="1687659238614" MODIFIED="1687663006829">
<node TEXT="有真则真" ID="ID_350853628" CREATED="1687659311778" MODIFIED="1687659317098"/>
</node>
<node TEXT="! 逻辑非运算" ID="ID_1843300214" CREATED="1687659239109" MODIFIED="1687659301277">
<node TEXT="真变假，假变真" ID="ID_295824307" CREATED="1687659318858" MODIFIED="1687659328235"/>
</node>
</node>
<node TEXT="位运算" FOLDED="true" ID="ID_314029456" CREATED="1687658423675" MODIFIED="1687659506855" VGAP_QUANTITY="3 pt">
<node TEXT="&amp; 按位与运算" ID="ID_147928698" CREATED="1687659333496" MODIFIED="1687659350756"/>
<node TEXT="| 按位或运算" ID="ID_1570201422" CREATED="1687659333973" MODIFIED="1687659358781"/>
<node TEXT="not 按位非运算" ID="ID_1394530627" CREATED="1687659334414" MODIFIED="1687659365372"/>
<node TEXT="^ 按位异或运算" ID="ID_1709447903" CREATED="1687659335482" MODIFIED="1687659506855"/>
<node TEXT="&gt;&gt; 右移运算" ID="ID_129828868" CREATED="1687659403743" MODIFIED="1687659409592"/>
<node TEXT="&lt;&lt; 左移运算" ID="ID_553234610" CREATED="1687659404144" MODIFIED="1687659414592"/>
<node TEXT="&gt;&gt;&gt; 无符号右移运算" ID="ID_1709829742" CREATED="1687659419012" MODIFIED="1687659426662"/>
</node>
<node TEXT="条件运算" FOLDED="true" ID="ID_1635863085" CREATED="1687658424130" MODIFIED="1687658902803">
<node TEXT="? :  三元运算符" ID="ID_345904741" CREATED="1687659436613" MODIFIED="1687659460474">
<node TEXT="let val = 判断条件?真值:假值" ID="ID_563676337" CREATED="1687659461574" MODIFIED="1687659498443"/>
</node>
</node>
<node TEXT="其他运算" ID="ID_1009850431" CREATED="1687658424625" MODIFIED="1687658893226">
<node TEXT="类型检测运算" ID="ID_961668757" CREATED="1687659512403" MODIFIED="1687659527357">
<node TEXT="typeof  值" ID="ID_367242270" CREATED="1687659535308" MODIFIED="1687659541482"/>
</node>
<node TEXT="逗号运算" ID="ID_695516211" CREATED="1687659515199" MODIFIED="1687659532677">
<node TEXT="let num1 = 1, num2 =2,num3 = 3" ID="ID_1209061621" CREATED="1687659542616" MODIFIED="1687659569939"/>
</node>
<node TEXT="对象检测运算" ID="ID_1196735135" CREATED="1690562416094" MODIFIED="1690562420934">
<node TEXT="instanceof" ID="ID_78389741" CREATED="1690562421205" MODIFIED="1690562426726"/>
</node>
</node>
<node TEXT="字符串运算" ID="ID_816518723" CREATED="1690440607379" MODIFIED="1690440616887">
<node TEXT="+号可以连接字符串" ID="ID_542352008" CREATED="1690440618980" MODIFIED="1690440629891"/>
</node>
<node TEXT="" ID="ID_733391287" CREATED="1690510681906" MODIFIED="1690510681906"/>
</node>
<node TEXT="如何使用JavaScript" FOLDED="true" POSITION="top_or_left" ID="ID_1770519758" CREATED="1687642609547" MODIFIED="1687642856769">
<node TEXT="&lt;scrtipt&gt;标签" FOLDED="true" ID="ID_367997038" CREATED="1687645999334" MODIFIED="1687646144432"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
    </p>
    <p>
      
    </p>
    <p>
      charset：可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
    </p>
    <p>
      
    </p>
    <p>
      crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin= &quot;anonymous&quot;配置文件请求不必设置凭据标志。crossorigin=&quot;use-credentials&quot;设置凭据标志，意味着出站请求会包含凭据。
    </p>
    <p>
      
    </p>
    <p>
      defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。
    </p>
    <p>
      
    </p>
    <p>
      integrity：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。
    </p>
    <p>
      
    </p>
    <p>
      src：可选。表示包含要执行的代码的外部文件
    </p>
    <p>
      
    </p>
    <p>
      type：可选。代替language，表示代码块中脚本语言的内容类型（也称MIME类型）
    </p>
  </body>
</html></richcontent>
<node TEXT="使用script标签引入js文件" ID="ID_390850309" CREATED="1687645876998" MODIFIED="1687645889079">
<node ID="ID_244781185" CREATED="1687646047558" MODIFIED="1687646332277"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &lt;!DOCTYPE html&gt;
    </p>
    <p>
      &lt;html lang=&quot;en&quot;&gt;
    </p>
    <p>
      &lt;head&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta charset=&quot;UTF-8&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;title&gt;js使用方式2&lt;/title&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;<font color="#ff0000">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</font>
    </p>
    <p>
      &lt;/head&gt;
    </p>
    <p>
      &lt;body&gt;
    </p>
    <p>
      
    </p>
    <p>
      &lt;/body&gt;
    </p>
    <p>
      &lt;/html&gt;
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="直接在页面中使用script嵌入js代码" POSITION="top_or_left" ID="ID_732253952" CREATED="1687645877556" MODIFIED="1687645908719">
<node ID="ID_868155116" CREATED="1687646158946" MODIFIED="1687646343538"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &lt;!DOCTYPE html&gt;
    </p>
    <p>
      &lt;html lang=&quot;en&quot;&gt;
    </p>
    <p>
      &lt;head&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta charset=&quot;UTF-8&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;style&gt;
    </p>
    <p>
      
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;/style&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;title&gt;js使用方式&lt;/title&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;<font color="#ff0000">&lt;script&gt; </font>
    </p>
    <p>
      <font color="#ff0000">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;function js(){ </font>
    </p>
    <p>
      <font color="#ff0000">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;alert('页面中嵌入JS方法') </font>
    </p>
    <p>
      <font color="#ff0000">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;} </font>
    </p>
    <p>
      
    </p>
    <p>
      <font color="#ff0000">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;js() </font>
    </p>
    <p>
      <font color="#ff0000">&#xa0;&#xa0;&#xa0;&#xa0;&lt;/script&gt;</font>
    </p>
    <p>
      &lt;/head&gt;
    </p>
    <p>
      &lt;body&gt;
    </p>
    <p>
      
    </p>
    <p>
      &lt;/body&gt;
    </p>
    <p>
      &lt;/html&gt;
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="在html标签中使用部分属性赋值方式添加" FOLDED="true" ID="ID_545076455" CREATED="1687645878111" MODIFIED="1687645936057">
<node ID="ID_1199427363" CREATED="1687646452483" MODIFIED="1687646482963"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &lt;!DOCTYPE html&gt;
    </p>
    <p>
      &lt;html lang=&quot;en&quot;&gt;
    </p>
    <p>
      &lt;head&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta charset=&quot;UTF-8&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;style&gt;
    </p>
    <p>
      
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;/style&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;title&gt;js使用方法3&lt;/title&gt;
    </p>
    <p>
      &lt;/head&gt;
    </p>
    <p>
      &lt;body&gt;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&lt;h1 <font color="#f7473b">onclick=&quot;javascript:alert('元素中直接使用js')&quot;</font>&gt;点击有喜！&lt;/h1&gt;
    </p>
    <p>
      &lt;/body&gt;
    </p>
    <p>
      &lt;/html&gt;
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="流程控制" FOLDED="true" POSITION="bottom_or_right" ID="ID_1410370445" CREATED="1687642610239" MODIFIED="1687644799234">
<node TEXT="分支" FOLDED="true" ID="ID_126507737" CREATED="1687662273300" MODIFIED="1687662295693">
<node TEXT="单项分支" FOLDED="true" ID="ID_53149065" CREATED="1687662443754" MODIFIED="1687662451591">
<node TEXT="if(判断条件){&#xa;    //js语句&#xa;}" ID="ID_1516727565" CREATED="1687663013234" MODIFIED="1687663050143"/>
<node TEXT="if(判断条件)&#xa;    //js语句" ID="ID_656267688" CREATED="1687663051341" MODIFIED="1687663056038"/>
</node>
<node TEXT="双向分支" FOLDED="true" ID="ID_43405689" CREATED="1687662444326" MODIFIED="1687662455859">
<node TEXT="if(判断条件){&#xa;    //js语句&#xa;}else{&#xa;    //js语句&#xa;}" ID="ID_1515058726" CREATED="1687663064426" MODIFIED="1687663080049"/>
<node TEXT="if(判断条件)&#xa;    //js语句&#xa;else&#xa;    //js语句" ID="ID_1420664889" CREATED="1687663069032" MODIFIED="1687663090818"/>
</node>
<node TEXT="多项分支" FOLDED="true" ID="ID_1856241297" CREATED="1687662446257" MODIFIED="1687662460020">
<node TEXT="if(判断条件) {&#xa;    //js语句&#xa;}else if{&#xa;    //js语句&#xa;}else if{&#xa;    //js语句&#xa;}...&#xa;else{&#xa;&#xa;}" ID="ID_1872237806" CREATED="1687663095920" MODIFIED="1687663168205"/>
</node>
<node TEXT="switch分支" FOLDED="true" ID="ID_1446978750" CREATED="1687662846534" MODIFIED="1687662851025">
<node TEXT="switch(变量){&#xa;    case  值1：&#xa;           js语句;&#xa;    case  值2：&#xa;           js语句;&#xa;    ...&#xa;    default:&#xa;          js语句;&#xa;}" ID="ID_403848211" CREATED="1687663172402" MODIFIED="1687663241210"/>
</node>
</node>
<node TEXT="循环" ID="ID_644602518" CREATED="1687662273926" MODIFIED="1687662298479">
<node TEXT="do-while循环" FOLDED="true" ID="ID_1399858935" CREATED="1687662463110" MODIFIED="1687663485368"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      do-while语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。
    </p>
  </body>
</html></richcontent>
<node TEXT="do{&#xa;    循环体&#xa;}while(判断条件);" ID="ID_590896088" CREATED="1687663265750" MODIFIED="1687663305938"/>
</node>
<node TEXT="while循环" FOLDED="true" ID="ID_1205980729" CREATED="1687662463560" MODIFIED="1687663469037"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      while语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while循环体内的代码有可能不会执行。
    </p>
  </body>
</html></richcontent>
<node TEXT="while(判断条件){&#xa;    循环体&#xa;}" ID="ID_1896870181" CREATED="1687663311156" MODIFIED="1687663415520"/>
</node>
<node TEXT="for循环" FOLDED="true" ID="ID_60142608" CREATED="1687662464017" MODIFIED="1687663505168"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      for语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式
    </p>
  </body>
</html></richcontent>
<node ID="ID_23442579" CREATED="1687663339556" MODIFIED="1687663408522"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      for(初始化变量;判断条件;自增自减运算){
    </p>
    <p>
      <b>&#xa0;&#xa0;&#xa0;&#xa0;循环体</b>
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="for-in循环" FOLDED="true" ID="ID_711230984" CREATED="1687662486296" MODIFIED="1687663521612"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      for-in语句是一种严格的迭代语句，用于枚举对象中的非符号键属性
    </p>
  </body>
</html></richcontent>
<node TEXT="for ( 变量  in 对象) {&#xa;   循环体&#xa;}" FOLDED="true" ID="ID_1678064545" CREATED="1687663522332" MODIFIED="1687664345964">
<node ID="ID_528296335" CREATED="1687664347532" MODIFIED="1687664475606"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      for (<font color="#008000">const</font>&#xa0;propName in window) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;console.log(propName);&#xa0;
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      推荐遍历是使用const定义常量来使用，
    </p>
    <p>
      因为该循环属于严格迭代，每次循环相当于新建了一个代码块，循环当此的常量不会被下次重新赋值
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node TEXT="for-of循环" ID="ID_706596124" CREATED="1687662497672" MODIFIED="1687664605066"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      for-of语句是一种严格的迭代语句，用于遍历可迭代对象的元素，例如数组中的每个元素
    </p>
  </body>
</html></richcontent>
<node TEXT="for ( 变量  of 可迭代对象) {&#xa;   循环体&#xa;}" FOLDED="true" ID="ID_1855063885" CREATED="1687664510288" MODIFIED="1687664568848">
<node ID="ID_1644297842" CREATED="1687664511555" MODIFIED="1687664627017"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      for (<font color="#008000">const</font>&#xa0;el of [2,4,6,8]) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;console.log(el);
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      与for循环一样，这里控制语句中的const也不是必需的。但为了确保这个局部变量不被修改，推荐使用const。for-of循环会按照可迭代对象的next()方法产生值的顺序迭代元素。
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
</node>
<node TEXT="其他" FOLDED="true" ID="ID_983944496" CREATED="1687662274487" MODIFIED="1687662805318">
<node TEXT="break语句" ID="ID_507607370" CREATED="1687662806458" MODIFIED="1687664864873"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      停止代码执行，并且跳出分支或者循环
    </p>
  </body>
</html></richcontent>
</node>
<node TEXT="continue语句" ID="ID_351480880" CREATED="1687662806876" MODIFIED="1687664880161"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      停止本次代码执行，开始执行下一次循环
    </p>
  </body>
</html></richcontent>
</node>
<node TEXT="with语句" ID="ID_25042264" CREATED="1687662807501" MODIFIED="1687664762857"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      with语句的用途是将代码作用域设置为特定的对象
    </p>
  </body>
</html></richcontent>
<node TEXT="wiith(对象){&#xa;    //代码&#xa;}" ID="ID_1956958792" CREATED="1687664757026" MODIFIED="1687665057906"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      with内的变量都会先查询是否是局部变量，如果不是则查找是否是指定对象的属性
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="标签语句" ID="ID_515214434" CREATED="1687665093926" MODIFIED="1687665246542"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      用于循环的标注。方便break或者continue跳出指定的循环，break与continue默认跳出当前循环
    </p>
  </body>
</html></richcontent>
<node ID="ID_1941328827" CREATED="1687665136328" MODIFIED="1690475110481"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      let num = 0;
    </p>
    <p>
      <font color="#008000">outermost</font>: for (let i = 0; i &lt; 10; i++) {&#xa0;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;for (let j = 0; j &lt; 10; j++) {&#xa0;&#xa0;&#xa0;&#xa0;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;if (i == 5 &amp;&amp; j == 5) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;break <font color="#008000">outermost</font>; &#xa0;&#xa0;&#xa0;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;}
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;num++;&#xa0;&#xa0;&#xa0;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;}
    </p>
    <p>
      } console.log(num); // 55
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="try...catch" ID="ID_312626600" CREATED="1690954301866" MODIFIED="1690954314143">
<node TEXT="不是分支" ID="ID_1634751224" CREATED="1690954319846" MODIFIED="1690954324168"/>
<node TEXT="Error内置对象" ID="ID_303296032" CREATED="1690954352578" MODIFIED="1690954363812"/>
</node>
</node>
</node>
<node TEXT="语法基础" FOLDED="true" POSITION="top_or_left" ID="ID_1128000740" CREATED="1687642611014" MODIFIED="1687644652233">
<node TEXT="大小写区分" ID="ID_783419799" CREATED="1687644671690" MODIFIED="1687645023109">
<node TEXT="ECMAScript中一切都区分大小写。" ID="ID_366986348" CREATED="1687645085149" MODIFIED="1687645086614"/>
</node>
<node TEXT="标识符" FOLDED="true" ID="ID_1910572912" CREATED="1687644692862" MODIFIED="1687645172229"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      所谓标识符，就是变量、函数、属性或函数参数的名称。
    </p>
  </body>
</html></richcontent>
<node TEXT="1、第一个字符必须是一个字母、下划线（_）或美元符号（$）；" ID="ID_408169853" CREATED="1687645097582" MODIFIED="1687645221089"/>
<node TEXT="2、剩下的其他字符可以是字母、下划线、美元符号或数字" ID="ID_1211931693" CREATED="1687645196886" MODIFIED="1687645224678"/>
</node>
<node TEXT="注释" FOLDED="true" ID="ID_50482739" CREATED="1687645030382" MODIFIED="1687645343512"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ECMAScript采用C语言风格的注释，包括单行注释和块注释,
    </p>
    <p>
      注释的作用：
    </p>
    <p>
      
    </p>
    <p>
      1.对代码进行标注，增加代码可读性与方便后期维护
    </p>
    <p>
      2.对代码进行暂时取消，方便调试排查错误
    </p>
  </body>
</html></richcontent>
<node TEXT="单行注释" ID="ID_132038489" CREATED="1687645122122" MODIFIED="1687645140657">
<node TEXT="// 单行注释" ID="ID_1007429497" CREATED="1687645242811" MODIFIED="1687645244228"/>
</node>
<node TEXT="多行注释" ID="ID_1017650745" CREATED="1687645140973" MODIFIED="1687645149323">
<node TEXT="/*&#xa;这是多行注释&#xa;这是多行注释&#xa;*/" ID="ID_823052227" CREATED="1687645250459" MODIFIED="1687645261612"/>
</node>
</node>
<node TEXT="严格模式" FOLDED="true" ID="ID_883581185" CREATED="1687645036132" MODIFIED="1687645391740"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。
    </p>
  </body>
</html></richcontent>
<node TEXT="整个文件严格模式" ID="ID_1856050153" CREATED="1687645385732" MODIFIED="1687645407919">
<node TEXT="在脚本开头加上这一行：&#xa;&quot;use strict&quot;;" ID="ID_1464281910" CREATED="1687645427391" MODIFIED="1687645448246"/>
</node>
<node TEXT="单个函数严格模式" ID="ID_1257526078" CREATED="1687645409399" MODIFIED="1687645414405">
<node TEXT="function doSomething() {&#xa;   &quot;use strict&quot;;&#xa;    // 函数体&#xa;}" ID="ID_348544241" CREATED="1687645456729" MODIFIED="1687645475956"/>
</node>
<node TEXT="特征" FOLDED="true" ID="ID_795366068" CREATED="1690386706489" MODIFIED="1690386713652">
<node TEXT="不允许使用未声明的变量：" ID="ID_1741153948" CREATED="1690386714036" MODIFIED="1690386720483"/>
<node TEXT="不允许删除变量或对象。" ID="ID_1822813250" CREATED="1690386729086" MODIFIED="1690386733006"/>
<node TEXT="不允许删除函数。" ID="ID_1782602882" CREATED="1690386738958" MODIFIED="1690386744592"/>
<node TEXT="不允许变量重名:" ID="ID_1381331346" CREATED="1690386749529" MODIFIED="1690386751062"/>
<node TEXT="不允许使用八进制:" ID="ID_493015813" CREATED="1690386756597" MODIFIED="1690386760637"/>
<node TEXT="不允许使用转义字符:" ID="ID_1778201372" CREATED="1690386765260" MODIFIED="1690386766951"/>
<node TEXT="允许对只读属性赋值:" ID="ID_254166588" CREATED="1690386774691" MODIFIED="1690386778369"/>
<node TEXT="不允许对一个使用getter方法读取的属性进行赋值" ID="ID_997997224" CREATED="1690386784046" MODIFIED="1690386785724"/>
<node TEXT="不允许删除一个不允许删除的属性：" ID="ID_743247228" CREATED="1690386791171" MODIFIED="1690386794402"/>
<node TEXT="变量名不能使用 &quot;eval&quot; 字符串:" ID="ID_1024201128" CREATED="1690386800544" MODIFIED="1690386803814"/>
<node TEXT="变量名不能使用 &quot;arguments&quot; 字符串:" ID="ID_1600832473" CREATED="1690386809901" MODIFIED="1690386811497"/>
<node TEXT="不允许使用with语句:" ID="ID_161945909" CREATED="1690386826100" MODIFIED="1690386832667"/>
<node TEXT="在作用域 eval() 创建的变量不能被调用：" ID="ID_1905103616" CREATED="1690386838981" MODIFIED="1690386840749"/>
<node TEXT="禁止this关键字指向全局对象。" ID="ID_1913796994" CREATED="1690386846253" MODIFIED="1690386848074"/>
</node>
</node>
<node TEXT="关键字与保留字" FOLDED="true" ID="ID_644837289" CREATED="1687645051635" MODIFIED="1687645056118">
<node TEXT="关键字" FOLDED="true" ID="ID_487487900" CREATED="1687645639353" MODIFIED="1687645764648"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ECMAscript中已经使用的单词，都不允许被用户使用，这些单词就是关键字，因为用户使用会导致解析器运行出错！~！
    </p>
  </body>
</html></richcontent>
<node TEXT="break       do          in            typeof case        else        instanceof    var catch       export      new           void class       extends     return        while const       finally     super         with continue    for         switch        yield debugger    function    this default     if          throw delete      import      try" ID="ID_1927365643" CREATED="1687645660030" MODIFIED="1687645661740"/>
</node>
<node TEXT="保留字" FOLDED="true" ID="ID_424090279" CREATED="1687645640314" MODIFIED="1687645807744"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      未来可能被当作语法的单词，但是现在没有被使用，这些预留的单词就是保留字~
    </p>
  </body>
</html></richcontent>
<node TEXT="始终保留:&#xa;enum&#xa;严格模式下保留:&#xa;implements  package     public interface   protected   static let         private&#xa;模块代码中保留:&#xa;await" ID="ID_1897130400" CREATED="1687645675899" MODIFIED="1687645701725"/>
</node>
</node>
<node TEXT="命令分隔符" ID="ID_782973908" CREATED="1687645496817" MODIFIED="1687645588118"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ECMAScript中的语句以分号结尾，便于解析器知道哪里是一个语句的结尾。但是js中，换行的话也可与被解析为结束，所以不写分号直接换行也行，但是不推荐
    </p>
  </body>
</html></richcontent>
<node TEXT="let sum = a + b      // 没有分号也有效，但不推荐" ID="ID_1623999081" CREATED="1687645524119" MODIFIED="1687645606113"/>
<node TEXT="let diff = a - b;    // 加分号有效，推荐" ID="ID_1235139209" CREATED="1687645595963" MODIFIED="1687645607093"/>
</node>
</node>
<node TEXT="函数" FOLDED="true" POSITION="bottom_or_right" ID="ID_1824641751" CREATED="1687642611518" MODIFIED="1687644801870">
<node TEXT="声明函数方法" ID="ID_1891788037" CREATED="1687668479780" MODIFIED="1687668490509">
<node TEXT="声明函数" ID="ID_1800403904" CREATED="1687669393942" MODIFIED="1687669397944">
<node ID="ID_1733804753" CREATED="1687668568767" MODIFIED="1687670391936"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      方法1：使用函数结构
    </p>
    <p>
      function 函数名(<font color="#008000">参数,参数...</font>){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      参数不是必须的
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="表达式函数" ID="ID_1629030337" CREATED="1687668569373" MODIFIED="1687669845875"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      该方式声明的函数没有函数名，所以也叫做匿名函数
    </p>
  </body>
</html></richcontent>
<node ID="ID_1976207733" CREATED="1687669664800" MODIFIED="1687670397293"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      方法2：使用函数结构+赋值
    </p>
    <p>
      let&#xa0;&#xa0;变量名=function(<font color="#008000">参数,参数...</font>){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      参数不是必须的
    </p>
  </body>
</html></richcontent>
</node>
<node ID="ID_33587761" CREATED="1687669732614" MODIFIED="1687670402935"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      方法3：使用函数构造方法(不推荐)
    </p>
    <p>
      let 变量 = new Function(<font color="#008000">参数,参数...</font>函数体)
    </p>
  </body>
</html>
</richcontent>
<richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      参数不是必须的
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="箭头函数" ID="ID_946894258" CREATED="1687668569754" MODIFIED="1687669905802"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      ECMAScript&#xa0;&#xa0;6新增了使用胖箭头（=&gt;）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。
    </p>
    <p>
      
    </p>
    <p>
      
    </p>
    <p>
      该方式创建的函数功能特性与表达式函数一致，只是语法更加精简
    </p>
  </body>
</html></richcontent>
<node TEXT="方法4：使用箭头函数结构&#xa;let  变量名=function(参数,参数...){&#xa;    //函数体&#xa;}" ID="ID_1091801784" CREATED="1687669912355" MODIFIED="1687671090120"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      参数不是必须的
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node TEXT="查看函数名称" FOLDED="true" ID="ID_539101543" CREATED="1687670476701" MODIFIED="1687670484614">
<node TEXT="函数变量/函数名.name" FOLDED="true" ID="ID_921867305" CREATED="1687670502063" MODIFIED="1687670513181">
<node TEXT="function foo() {}&#xa;let bar = function() {};&#xa;let baz = () =&gt; {};&#xa;&#xa;console.log(foo.name);               // foo&#xa;console.log(bar.name);               // bar&#xa;console.log(baz.name);               // baz&#xa;console.log((() =&gt; {}).name);        //（空字符串）console.log((new Function()).name);  // anonymous" ID="ID_300377311" CREATED="1687670513711" MODIFIED="1687670681594"/>
</node>
</node>
<node TEXT="函数调用" FOLDED="true" ID="ID_1699124329" CREATED="1687670904365" MODIFIED="1687670956233"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      函数定义后不会自动运行，需要在使用的时候调用，调用方式为：函数名()的方式
    </p>
  </body>
</html></richcontent>
<node TEXT="声明函数" FOLDED="true" ID="ID_1488514784" CREATED="1687670963451" MODIFIED="1687670970259">
<node ID="ID_1823880850" CREATED="1687671006410" MODIFIED="1687671116590"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      function 函数名(参数,参数...){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      }
    </p>
    <p>
      //调用函数
    </p>
    <p>
      <font color="#ff0000">函数名(参数,参数...)</font>
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="表达式函数" FOLDED="true" ID="ID_299014628" CREATED="1687670964206" MODIFIED="1687671042827" VGAP_QUANTITY="3 pt">
<node ID="ID_1186503287" CREATED="1687671042343" MODIFIED="1687671185929"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      let&#xa0;&#xa0;变量名=function(参数,参数...){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      }
    </p>
    <p>
      //调用函数
    </p>
    <p>
      <font color="#ff0000">变量名()</font>
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1430838204" CREATED="1687671162674" MODIFIED="1687671234495"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      自执行函数：
    </p>
    <p>
      (function(<font color="#008000">参数,参数...</font>){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      })(<font color="#008000">参数,参数...</font>)
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="箭头函数" FOLDED="true" ID="ID_547309139" CREATED="1687670981816" MODIFIED="1687670985142">
<node ID="ID_1662849398" CREATED="1687671090447" MODIFIED="1687671130211"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      let&#xa0;&#xa0;变量名=function(参数,参数...){
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//函数体
    </p>
    <p>
      }
    </p>
    <p>
      //调用函数
    </p>
    <p>
      <font color="#ff0000">变量名()</font>
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="函数参数" FOLDED="true" ID="ID_1931482779" CREATED="1687671275192" MODIFIED="1687671485209" VGAP_QUANTITY="3 pt">
<node TEXT="形参" FOLDED="true" ID="ID_1557734725" CREATED="1687671478865" MODIFIED="1687671484103">
<node TEXT="在定义函数的()中的变量叫做形参：形式上的参数，可以理解为占位" ID="ID_545175667" CREATED="1687671489102" MODIFIED="1687671530109"/>
</node>
<node TEXT="实参" FOLDED="true" ID="ID_1209777497" CREATED="1687671479651" MODIFIED="1687671487540">
<node TEXT="在调用函数的()中的值/变量叫做实参：实际上的内容" ID="ID_651719222" CREATED="1687671534503" MODIFIED="1687671559288"/>
</node>
<node TEXT="参数传递" FOLDED="true" ID="ID_267458490" CREATED="1687671565433" MODIFIED="1687671570817">
<node TEXT="参数的传递就是将实参的值，借由形参传入函数内部使用的" ID="ID_406111584" CREATED="1687671645741" MODIFIED="1687671673679">
<node TEXT="function sum(x,y){&#xa;    let result = x + y;&#xa;    console.log(sum)&#xa;}&#xa;&#xa;sum(5,6) //结果为11" ID="ID_387889615" CREATED="1687671686415" MODIFIED="1687671767395"/>
</node>
</node>
<node TEXT="arguments" FOLDED="true" ID="ID_1071804187" CREATED="1687671570925" MODIFIED="1687672634361"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      JS中的函数实参允许和实参数量不同，可以多，可以少。
    </p>
    <p>
      但是在函数内部会有一个专用的变量接受所有参数组成的数组对象
    </p>
    <p>
      。它既是arguments
    </p>
    <p>
      
    </p>
    <p>
      1. arguments对象是函数内部专用的变量
    </p>
    <p>
      2.arguments对象可以接受所有传入实参组成的数组。
    </p>
    <p>
      3.箭头函数中没有arguments对象
    </p>
    <p>
      
    </p>
    <p>
      该对象无法for...in 迭代
    </p>
  </body>
</html></richcontent>
<node TEXT="length" ID="ID_1939485827" CREATED="1687672049982" MODIFIED="1687672639268">
<node TEXT="传入实参的个数" ID="ID_1632021127" CREATED="1687672645539" MODIFIED="1687672655240"/>
</node>
<node TEXT="callee" ID="ID_285097002" CREATED="1687672050620" MODIFIED="1687672732191"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      代表当前函数本身，可以在递归函数中使用
    </p>
  </body>
</html></richcontent>
<node TEXT="caller" ID="ID_1298484570" CREATED="1687672684330" MODIFIED="1687672695987">
<node TEXT="代表调用当前函数的函数" ID="ID_88237290" CREATED="1687672770324" MODIFIED="1690598122313"/>
</node>
</node>
<node TEXT="callee" ID="ID_229949175" CREATED="1690598098275" MODIFIED="1690598110171">
<node TEXT="代表当前函数本身，可以在递归函数中使用" ID="ID_1363941647" CREATED="1690598110887" MODIFIED="1690598115165"/>
</node>
</node>
<node TEXT="默认值" FOLDED="true" ID="ID_891682162" CREATED="1687672851886" MODIFIED="1687673476757"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      默认值，可以认为是备胎，在没有传入实参的时候，使用的值
    </p>
  </body>
</html></richcontent>
<node TEXT="ES5时期，是不允许给形参设置默认值，都是在函数内部判断是否是undefined然后进行赋值" ID="ID_808899021" CREATED="1687673018141" MODIFIED="1687673049326">
<node ID="ID_545187834" CREATED="1687673188823" MODIFIED="1687673306642"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      function person(name) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;//此位置通过判断设置默认值
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;<font color="#ff0000">&#xa0;name = (typeof name !== 'undefined') ? name : 'john';</font>
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;console.log(name)
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="ES6时代，允许和其他语言一样设置默认值了" ID="ID_128279626" CREATED="1687673020667" MODIFIED="1687673100094">
<node ID="ID_1055748621" CREATED="1687673314911" MODIFIED="1687673437436"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      function person(<font color="#ff0000">name='john'</font>) { //形参位置设置
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;console.log(name)
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="收集参数(形参)" FOLDED="true" ID="ID_1818689353" CREATED="1687743505084" MODIFIED="1687753125430">
<node TEXT="在函数形参最后使用...变量可以收集未被形参接受的参数" ID="ID_610287854" CREATED="1687753001732" MODIFIED="1687753038185">
<node ID="ID_77556630" CREATED="1687753041330" MODIFIED="1687753252356"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      let func = (x,<font color="#ff0000">...values</font>)=&gt;{
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;console.log(x,values)
    </p>
    <p>
      }
    </p>
    <p>
      
    </p>
    <p>
      func(1,2,3,4,6)
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="扩展参数(实参)" FOLDED="true" ID="ID_799198674" CREATED="1687743516655" MODIFIED="1687753136049">
<node TEXT="在实参处可以使用...类数组格式传入当作多个实参传入" ID="ID_1876716956" CREATED="1687753136591" MODIFIED="1687753173565">
<node ID="ID_508633374" CREATED="1687753222371" MODIFIED="1687753371577"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      let func = (x,y,z)=&gt;{
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;console.log(x,y,z)
    </p>
    <p>
      }
    </p>
    <p>
      
    </p>
    <p>
      <font color="#ff0000">func(...[2,3,5])</font>//相当于func.apply(null,[2,3,5]);
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
<node TEXT="递归" FOLDED="true" ID="ID_443631268" CREATED="1687753452528" MODIFIED="1687753550865">
<node TEXT="递归函数通常的形式是一个函数通过名称调用自己" ID="ID_1828187360" CREATED="1687753585101" MODIFIED="1687753586718">
<node ID="ID_1669738923" CREATED="1687753618194" MODIFIED="1687753683104"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      function factorial(num) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;if (num &lt;= 1) {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;return 1;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;} else {
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;return <font color="#ff0000">num * arguments.callee(num - 1);</font>
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;}
    </p>
    <p>
      }
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="闭包" FOLDED="true" ID="ID_1648554832" CREATED="1687753552936" MODIFIED="1687753555595">
<node TEXT="闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的" ID="ID_705253863" CREATED="1687753704976" MODIFIED="1687753777911"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      注意因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node TEXT="自执行函数" FOLDED="true" ID="ID_1791067961" CREATED="1687753559121" MODIFIED="1687753568947">
<node TEXT="立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately  Invoked  Function  Expression）" ID="ID_1321943037" CREATED="1687753794663" MODIFIED="1687753796386">
<node TEXT="(function() {&#xa;   // 块级作用域&#xa;})();" ID="ID_734357878" CREATED="1687753805524" MODIFIED="1687753815470"/>
</node>
</node>
<node TEXT="函数方法&amp;属性" POSITION="bottom_or_right" ID="ID_640402632" CREATED="1687743310286" MODIFIED="1687753520672">
<node TEXT="call" ID="ID_106674344" CREATED="1687753474645" MODIFIED="1687753478282">
<node TEXT="调用函数，指定函数的内部对象，子类调用父类构造方法时使用" ID="ID_535839296" CREATED="1691215805534" MODIFIED="1691215851801"/>
</node>
<node TEXT="apply" ID="ID_1280377505" CREATED="1687753475085" MODIFIED="1687753482450">
<node TEXT="调用函数，指定函数的内部对象，子类调用父类构造方法时使用" ID="ID_1837506997" CREATED="1691215855104" MODIFIED="1691215857549"/>
</node>
<node TEXT="bind" ID="ID_1151960253" CREATED="1687753475483" MODIFIED="1687753484670"/>
<node TEXT="length" ID="ID_231501741" CREATED="1687753502041" MODIFIED="1687753506380">
<node TEXT="获取形参的个数" ID="ID_1085852504" CREATED="1690616355820" MODIFIED="1690616363393"/>
</node>
<node TEXT="prototype" ID="ID_372825212" CREATED="1687753512360" MODIFIED="1687753514350"/>
</node>
<node TEXT="变量作用域" FOLDED="true" ID="ID_1925706534" CREATED="1690478243230" MODIFIED="1690478248482">
<node TEXT="全局变量" ID="ID_954438279" CREATED="1690616083071" MODIFIED="1690616087202">
<node TEXT="在函数外部声明的变量" ID="ID_1537441623" CREATED="1690616099477" MODIFIED="1690616110458"/>
</node>
<node TEXT="局部变量" ID="ID_653547309" CREATED="1690616083876" MODIFIED="1690616112636" VGAP_QUANTITY="3 pt">
<node TEXT="在函数内部声明的变量" ID="ID_412408038" CREATED="1690616111947" MODIFIED="1690616121882"/>
</node>
<node TEXT="变量作用域链" ID="ID_237386246" CREATED="1690616091654" MODIFIED="1690616097933">
<node TEXT="变量可以在函数内层逐层传递" ID="ID_43976327" CREATED="1690616125999" MODIFIED="1690616136777"/>
</node>
</node>
</node>
<node TEXT="对象" FOLDED="true" POSITION="bottom_or_right" ID="ID_946921512" CREATED="1687644835986" MODIFIED="1687644912414">
<node TEXT="对象创建方法" FOLDED="true" ID="ID_99148057" CREATED="1690476061261" MODIFIED="1690476084861">
<node TEXT="工厂模式" FOLDED="true" ID="ID_619631922" CREATED="1690477978758" MODIFIED="1690562032486"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      基于object对象创建对象
    </p>
  </body>
</html></richcontent>
<node TEXT="        function createObj(name,sex){&#xa;            let o = new Object();&#xa;            o.name = name;&#xa;            o.sex = sex;&#xa;            o.say = function(){&#xa;                console.log(this.name);&#xa;            };&#xa;&#xa;            return o;&#xa;        }" ID="ID_1712372425" CREATED="1690477989900" MODIFIED="1690712641775">
<node TEXT="该方法创建的对象都是基于object对象创建的" ID="ID_356136356" CREATED="1690712007034" MODIFIED="1690712027149"/>
</node>
</node>
<node TEXT="构造函数模式" FOLDED="true" ID="ID_1054688149" CREATED="1690477997793" MODIFIED="1690562055217"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      自己创建一个对象原型
    </p>
  </body>
</html></richcontent>
<node TEXT="       function Student(){&#xa;            this.name = name;&#xa;            this.sex = sex;&#xa;            this.say = function(){&#xa;                console.log(this.name)&#xa;            }&#xa;        }" FOLDED="true" ID="ID_1300930649" CREATED="1690478005805" MODIFIED="1690712635986">
<node TEXT="该方法是根据新的对象原型及构造方法创建（成员在构造函数中，未来在实例中）" ID="ID_1982122869" CREATED="1690712151235" MODIFIED="1690712310002"/>
</node>
</node>
<node TEXT="原型模式" FOLDED="true" ID="ID_1392522522" CREATED="1690478032087" MODIFIED="1690478041290">
<node TEXT="       function Student(){&#xa;            Student.prototype.name = name;&#xa;            Student.prototype.sex = sex;&#xa;            Student.prototype.say = function(){&#xa;                console.log(this.name)&#xa;            }&#xa;        }" FOLDED="true" ID="ID_1261535743" CREATED="1690478033587" MODIFIED="1690712629889">
<node TEXT="该方法是根据新的对象原型及构造方法创建（成员在原型中）" ID="ID_1139332067" CREATED="1690712249602" MODIFIED="1690712286881"/>
</node>
</node>
<node TEXT="对象迭代" FOLDED="true" ID="ID_547681490" CREATED="1690478064352" MODIFIED="1690478067865">
<node TEXT="       function Student(){&#xa;&#xa;        }&#xa;       Student.prototype = {&#xa;                 name:name,&#xa;                 sex:sex,&#xa;                 say:function(){&#xa;                     console.log(this.name)&#xa;                 }&#xa;              }" ID="ID_125537624" CREATED="1690712650224" MODIFIED="1690774055116">
<node TEXT="       function Student(){&#xa;&#xa;        }&#xa;Student.prototype = {&#xa;                 constructor:Student,&#xa;                 name:name,&#xa;                 sex:sex,&#xa;                 say:function(){&#xa;                     console.log(this.name)&#xa;                 }&#xa;              }" ID="ID_1231775325" CREATED="1690713975931" MODIFIED="1690774063919">
<node TEXT="       function Student(){&#xa;&#xa;        }&#xa;Student.prototype = {&#xa;                 constructor:Student,&#xa;                 name:name,&#xa;                 sex:sex,&#xa;                 say:function(){&#xa;                     console.log(this.name)&#xa;                 }&#xa;              }&#xa;// 恢复 constructor 属性&#xa;Object.defineProperty(Student.prototype, &quot;constructor&quot;, {&#xa; enumerable: false,&#xa; value:Student&#xa;});" ID="ID_835229594" CREATED="1690713975931" MODIFIED="1690774069554"/>
</node>
</node>
</node>
<node TEXT="object构建对象" FOLDED="true" ID="ID_929969484" CREATED="1690478080381" MODIFIED="1690478107018">
<node TEXT="使用Object()构造方法创建" ID="ID_1996740848" CREATED="1690476091455" MODIFIED="1690476121852">
<node TEXT="        let person = new Object();&#xa;        person.name = &apos;小姐姐&apos;;&#xa;        person.sex = &apos;woman&apos;;&#xa;        person.say=function(){&#xa;            console.log(&apos;你好&apos;);&#xa;        }" ID="ID_86037808" CREATED="1690476145220" MODIFIED="1690711690082"/>
</node>
<node TEXT="使用对象字面量方法创建" ID="ID_672928101" CREATED="1690476092014" MODIFIED="1690476137167">
<node TEXT=" let person = {&#xa;            name:&apos;小姐姐&apos;,&#xa;            sex:&apos;woman&apos;,&#xa;            say:function(){&#xa;                console.log(&apos;你好&apos;);&#xa;            }&#xa;        }" ID="ID_354666219" CREATED="1690476154169" MODIFIED="1690711745510"/>
</node>
</node>
<node TEXT="new.target" ID="ID_1257205497" CREATED="1690723001831" MODIFIED="1690723007406">
<node TEXT="区分函数调用" ID="ID_415796764" CREATED="1690723008078" MODIFIED="1690723014518"/>
</node>
</node>
<node TEXT="对象成员操作" FOLDED="true" ID="ID_181306738" CREATED="1690476061845" MODIFIED="1690476189219">
<node TEXT="添加成员" ID="ID_833887975" CREATED="1690476189525" MODIFIED="1690476198691">
<node TEXT="对象.属性=值" ID="ID_866198731" CREATED="1690711765836" MODIFIED="1690711778774"/>
</node>
<node TEXT="删除成员" ID="ID_70124847" CREATED="1690476190272" MODIFIED="1690476203686">
<node TEXT="delete 对象.属性" ID="ID_1428971657" CREATED="1690711780559" MODIFIED="1690711788601"/>
</node>
<node TEXT="修改成员" ID="ID_1002061060" CREATED="1690476190850" MODIFIED="1690476208190">
<node TEXT="对象.属性=新值" ID="ID_1291313571" CREATED="1690711844439" MODIFIED="1690711851790"/>
</node>
<node TEXT="语法糖" ID="ID_1375421734" CREATED="1690477399950" MODIFIED="1690477406595">
<node TEXT="属性简写" FOLDED="true" ID="ID_1760927692" CREATED="1690477414352" MODIFIED="1690477422068">
<node TEXT="let name = &apos;Matt&apos;; &#xd;&#xa;let person = { &#xd;&#xa; name: name &#xd;&#xa;};" ID="ID_1697141416" CREATED="1690477427864" MODIFIED="1690477430684"/>
<node TEXT="let name = &apos;Matt&apos;; &#xd;&#xa;let person = { &#xd;&#xa; name &#xd;&#xa;};" ID="ID_671068708" CREATED="1690477436090" MODIFIED="1690477437650"/>
</node>
<node TEXT="可计算属性" FOLDED="true" ID="ID_1534309184" CREATED="1690477461630" MODIFIED="1690477463001">
<node TEXT="const nameKey = &apos;name&apos;; &#xd;&#xa;const ageKey = &apos;age&apos;; &#xd;&#xa;const jobKey = &apos;job&apos;; &#xd;&#xa;let person = { &#xd;&#xa; [nameKey]: &apos;Matt&apos;, &#xd;&#xa; [ageKey]: 27, &#xd;&#xa; [jobKey]: &apos;Software engineer&apos; &#xd;&#xa;};" ID="ID_490484848" CREATED="1690477497506" MODIFIED="1690477504250"/>
</node>
<node TEXT=" 简写方法名" FOLDED="true" ID="ID_443943679" CREATED="1690477521123" MODIFIED="1690477524238">
<node TEXT="let person = { &#xd;&#xa; sayName: function(name) { &#xd;&#xa; console.log(`My name is ${name}`); &#xd;&#xa; } &#xd;&#xa;};" ID="ID_966087531" CREATED="1690477537813" MODIFIED="1690477539497"/>
<node TEXT="let person = { &#xd;&#xa; sayName(name) { &#xd;&#xa; console.log(`My name is ${name}`); &#xd;&#xa; } &#xd;&#xa;};" ID="ID_1984932750" CREATED="1690477548733" MODIFIED="1690477552800"/>
</node>
<node TEXT="对象解构" ID="ID_1504509340" CREATED="1690477580868" MODIFIED="1690477582487">
<node TEXT="// 不使用对象解构&#xd;&#xa;let person = { &#xd;&#xa; name: &apos;Matt&apos;, &#xd;&#xa; age: 27 &#xd;&#xa;}; &#xd;&#xa;&#xa;let personName = person.name, &#xd;&#xa; personAge = person.age;" ID="ID_1243789399" CREATED="1690477623552" MODIFIED="1690477631868"/>
<node TEXT=" name: &apos;Matt&apos;, &#xd;&#xa; age: 27 &#xd;&#xa;}; &#xd;&#xa;let { name: personName, age: personAge } = person;" ID="ID_1606359510" CREATED="1690477643268" MODIFIED="1690477645051"/>
<node TEXT=" 部分解构" ID="ID_1115321853" CREATED="1690477726270" MODIFIED="1690477735186">
<node TEXT="let person = { &#xd;&#xa; name: &apos;Matt&apos;, &#xd;&#xa; age: 27 &#xd;&#xa;}; &#xd;&#xa;let personName, personBar, personAge; &#xd;&#xa;try { &#xd;&#xa; // person.foo 是 undefined，因此会抛出错误&#xd;&#xa; ({name: personName, foo: { bar: personBar }, age: personAge} = person); &#xd;&#xa;} catch(e) {} &#xd;&#xa;console.log(personName, personBar, personAge); &#xd;&#xa;// Matt, undefined, undefined" ID="ID_1309378193" CREATED="1690477930286" MODIFIED="1690477931715"/>
</node>
<node TEXT="函数传参解构" ID="ID_298368619" CREATED="1690477735382" MODIFIED="1690784418338">
<node TEXT="let person = { &#xd;&#xa; name: &apos;Matt&apos;, &#xd;&#xa; age: 27 &#xd;&#xa;}; &#xd;&#xa;function printPerson(foo, {name, age}, bar) { &#xd;&#xa; console.log(arguments); &#xd;&#xa; console.log(name, age); &#xd;&#xa;} &#xd;&#xa;function printPerson2(foo, {name: personName, age: personAge}, bar) { &#xd;&#xa; console.log(arguments); &#xd;&#xa; console.log(personName, personAge); &#xd;&#xa;} &#xd;&#xa;printPerson(&apos;1st&apos;, person, &apos;2nd&apos;); &#xd;&#xa;// [&apos;1st&apos;, { name: &apos;Matt&apos;, age: 27 }, &apos;2nd&apos;] &#xd;&#xa;// &apos;Matt&apos;, 27 &#xd;&#xa;printPerson2(&apos;1st&apos;, person, &apos;2nd&apos;); &#xd;&#xa;// [&apos;1st&apos;, { name: &apos;Matt&apos;, age: 27 }, &apos;2nd&apos;] &#xd;&#xa;// &apos;Matt&apos;, 27" ID="ID_795388895" CREATED="1690477916015" MODIFIED="1690477917408"/>
</node>
</node>
</node>
</node>
<node TEXT="对象属性特性操作" FOLDED="true" ID="ID_1736958167" CREATED="1690476062363" MODIFIED="1690851827285">
<node TEXT="数据属性" ID="ID_1020743397" CREATED="1690476230388" MODIFIED="1690476231995">
<node TEXT="[[Configurable]]" ID="ID_604268550" CREATED="1690476249116" MODIFIED="1690476256605">
<node TEXT="表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特&#xa;性都是 true" ID="ID_1126547765" CREATED="1690476281628" MODIFIED="1690476375645"/>
</node>
<node TEXT="[[Enumerable]]" ID="ID_816276925" CREATED="1690476261873" MODIFIED="1690476263350">
<node TEXT="表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true" ID="ID_240365280" CREATED="1690476289730" MODIFIED="1690476358548"/>
</node>
<node TEXT="[[Writable]]" ID="ID_1652768740" CREATED="1690476268833" MODIFIED="1690476270245">
<node TEXT="表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是 true，" ID="ID_1959247593" CREATED="1690476299763" MODIFIED="1690476343889"/>
</node>
<node TEXT="[[Value]]" ID="ID_326686591" CREATED="1690476274898" MODIFIED="1690476331008" VGAP_QUANTITY="3 pt">
<node TEXT="包含属性实际的值。这个特性&#xd;&#xa;的默认值为 undefined。" ID="ID_1537910174" CREATED="1690476316029" MODIFIED="1690476337669"/>
</node>
</node>
<node TEXT="访问器属性" ID="ID_1809145195" CREATED="1690476239295" MODIFIED="1690476240954">
<node TEXT="[[Configurable]]" ID="ID_810753041" CREATED="1690476401198" MODIFIED="1690476407390">
<node TEXT="表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性&#xa;都是 true" ID="ID_831527189" CREATED="1690476430104" MODIFIED="1690476436441"/>
</node>
<node TEXT="[[Enumerable]]" ID="ID_825139875" CREATED="1690476407675" MODIFIED="1690476409391">
<node TEXT="表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对&#xd;象上的属性的这个特性都是 true。" ID="ID_1316002307" CREATED="1690476442292" MODIFIED="1690476445537"/>
</node>
<node TEXT="[[Get]]" ID="ID_1061785084" CREATED="1690476413581" MODIFIED="1690476415090">
<node TEXT="获取函数，在读取属性时调用。默认值为 undefined。" ID="ID_1953240020" CREATED="1690476450115" MODIFIED="1690476453083"/>
</node>
<node TEXT="[[Set]]" ID="ID_444818169" CREATED="1690476419119" MODIFIED="1690476420583">
<node TEXT="设置函数，在写入属性时调用。默认值为 undefined。" ID="ID_217591004" CREATED="1690476459475" MODIFIED="1690476460904"/>
</node>
</node>
<node TEXT="定义特性" ID="ID_763147934" CREATED="1690476542470" MODIFIED="1690476831064">
<node TEXT="Object.defineProperty(对象,&apos;属性名&apos;,描述符对象)" ID="ID_287592437" CREATED="1690476552588" MODIFIED="1690718494178">
<node TEXT="Object.defineProperty(person, &quot;name&quot;, { &#xd;&#xa; writable: false, &#xd;&#xa; value: &quot;Nicholas&quot; &#xd;&#xa;});" ID="ID_851178527" CREATED="1690476586694" MODIFIED="1690476683593"/>
</node>
<node TEXT="Object.defineProperties(对象,描述符对象)" ID="ID_536950196" CREATED="1690476716369" MODIFIED="1690781330397"/>
</node>
<node TEXT="读取属性的特性" ID="ID_37659248" CREATED="1690476839871" MODIFIED="1690476842451">
<node TEXT="Object.getOwnPropertyDescriptor(对象,描述符对象)" ID="ID_1754485015" CREATED="1690476861095" MODIFIED="1690476878523"/>
<node TEXT="Object.getOwnPropertyDescriptors(对象)" ID="ID_338414530" CREATED="1690476945424" MODIFIED="1690476962663"/>
</node>
<node TEXT="合并对象" FOLDED="true" ID="ID_575502905" CREATED="1690476972129" MODIFIED="1690476973796">
<node TEXT="Object.assign(目标对象,来源对象1,2,3...)" ID="ID_880277955" CREATED="1690477007192" MODIFIED="1690477115095">
<node TEXT="Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使&#xd;&#xa;用最后一个复制的值。" ID="ID_163414701" CREATED="1690477343338" MODIFIED="1690477344754"/>
</node>
</node>
<node TEXT="判断两个值是否相同" FOLDED="true" ID="ID_1687941308" CREATED="1690477217579" MODIFIED="1690781250632">
<node TEXT="Object.is(数据1,数据2)" ID="ID_1756141244" CREATED="1690477254432" MODIFIED="1690477299432">
<node TEXT="两个值都是 undefined&#xa;两个值都是 null&#xa;两个值都是 true 或者都是 false&#xa;两个值是由相同个数的字符按照相同的顺序组成的字符串&#xa;两个值指向同一个对象&#xa;两个值都是数字并且&#xa;  都是正零 +0&#xa;  都是负零 -0&#xa;  都是 NaN&#xa;  都是除零和 NaN 外的其它同一个数字" ID="ID_960222921" CREATED="1690477289469" MODIFIED="1690781273621"/>
</node>
</node>
</node>
<node TEXT="继承" FOLDED="true" ID="ID_1442182638" CREATED="1690476062789" MODIFIED="1690478206638">
<node TEXT="原型链" FOLDED="true" ID="ID_1382999349" CREATED="1690562123525" MODIFIED="1690562140567"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div>
      <span style="font-size: 9.48pt; font-family: Times New Roman; color: rgb(0,0,0)"><font size="9.48pt" face="Times New Roman" color="rgb(0,0,0)">ECMA-262 </font></span><span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">把</font></span><span style="font-size: 9.48pt; font-family: SimHei; color: rgb(0,0,0)"><font size="9.48pt" face="SimHei" color="rgb(0,0,0)">原型链</font></span><span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">定义为 </font></span><span style="font-size: 9.48pt; font-family: Times New Roman; color: rgb(0,0,0)"><font size="9.48pt" face="Times New Roman" color="rgb(0,0,0)">ECMAScript </font></span><span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">的主要继承方式</font></span>
    </div>
    <p>
      
    </p>
  </body>
</html></richcontent>
<node TEXT="//父构造方法与原型&#xa;function Father(){&#xa;      this.name = &apos;刘备&apos;;&#xa;}&#xa;&#xa;Father.prototype.say=function(){&#xa;      console.log(this.name)&#xa;}" ID="ID_133044469" CREATED="1690562179674" MODIFIED="1690729344423"/>
<node TEXT="//子构造方法&#xa;function Son(){&#xa;       this.name = &apos;阿斗&apos;&#xa;}" ID="ID_1447046339" CREATED="1690562194904" MODIFIED="1690729448715"/>
<node TEXT="//继承操作&#xa;Son.prototype = new Father();&#xa;//添加方法&#xa;Son.prototype.smile=function(){&#xa;}" POSITION="bottom_or_right" ID="ID_844670725" CREATED="1690729449643" MODIFIED="1690729455163"/>
<node TEXT="let lc = new Son();&#xa;console.log(lc)&#xa;lc.say();" POSITION="bottom_or_right" ID="ID_1103815332" CREATED="1690562208348" MODIFIED="1690722063813"/>
<node TEXT="问题" POSITION="bottom_or_right" ID="ID_522976227" CREATED="1690562468308" MODIFIED="1690562471829">
<node TEXT="原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会&#xd;在构造函数中定义而不会定义在原型上的原因。" ID="ID_574691689" CREATED="1690562472162" MODIFIED="1690562487764"/>
</node>
</node>
<node TEXT="经典继承" FOLDED="true" ID="ID_923085646" CREATED="1690562500010" MODIFIED="1690724439849"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      <font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">对象伪装/盗用构造函数</font>
    </p>
  </body>
</html></richcontent>
<node TEXT="//父构造方法与原型&#xa;function Father(age=1){&#xa;      this.name = &apos;刘备&apos;;&#xa;      this.age=age;&#xa;}&#xa;&#xa;Father.prototype.say=function(){&#xa;      console.log(this.name)&#xa;}" ID="ID_1935744895" CREATED="1690562562153" MODIFIED="1690729352223"/>
<node TEXT="//继承操作&#xa;function Son(){&#xa;      Father.call(this,99)；&#xa;      this.sex=&apos;man&apos;;&#xa;}" ID="ID_1400110117" CREATED="1690562571418" MODIFIED="1690726654273"/>
<node TEXT="let s = new Son();&#xa;console.log(s)&#xa;s.say() //报错" ID="ID_487293323" CREATED="1690562577903" MODIFIED="1690726597036"/>
<node TEXT="问题" ID="ID_332773125" CREATED="1690562610331" MODIFIED="1690562613395">
<node TEXT="使用构造函数模式自定义类型的问题：必须在构造函数中定义方法，因此父原型中函数不能重用" ID="ID_670117968" CREATED="1690562613697" MODIFIED="1690859497733"/>
</node>
</node>
<node TEXT="组合继承" FOLDED="true" ID="ID_844031225" CREATED="1690562643293" MODIFIED="1690726741257" VGAP_QUANTITY="3 pt"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div>
      <span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">叫伪经典继承&#xa0;&#xa0;综合了原型链和盗用构造函数</font></span>
    </div>
  </body>
</html></richcontent>
<node TEXT="//父构造方法与原型&#xa;function Father(age=1){&#xa;      this.name = &apos;刘备&apos;;&#xa;      this.age=age;&#xa;}&#xa;&#xa;Father.prototype.say=function(){&#xa;     //如果原型中有调用属性，最好可以在构造方法传值，方便子对象操作&#xa;      console.log(this.name)&#xa;}" ID="ID_984667844" CREATED="1690562679714" MODIFIED="1690729370960"/>
<node TEXT="//继承操作(属性)&#xa;function Son(){&#xa;      Father.call(this,99)；&#xa;      this.sex=&apos;man&apos;;&#xa;}" ID="ID_45760924" CREATED="1690562691076" MODIFIED="1690726753554"/>
<node TEXT="// 继承方法&#xa;Son.prototype=new Father();&#xa;//添加子对象方法&#xa;Son.prototype.smile=function(){}" ID="ID_1916404795" CREATED="1690562700011" MODIFIED="1690726849695"/>
<node TEXT="let s = new Son();&#xa;console.log(s)&#xa;s.say()" ID="ID_532652612" CREATED="1690562708191" MODIFIED="1690726902414"/>
<node TEXT="JavaScript 中使用最多的继承模式。而且组合继&#xd;&#xa;承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。" ID="ID_927586106" CREATED="1690729884265" MODIFIED="1690729889398"/>
</node>
<node TEXT="原型式继承" FOLDED="true" ID="ID_330010917" CREATED="1690562744089" MODIFIED="1690562745661">
<node TEXT="早期办法" ID="ID_1690510175" CREATED="1690562802906" MODIFIED="1690562822518"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div>
      <span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">这个 </font></span><span style="font-size: 9pt; font-family: Courier; color: rgb(0,0,0)"><font size="9pt" face="Courier" color="rgb(0,0,0)">object()</font></span><span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返 </font></span>
    </div>
    <div>
      <span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">回这个临时类型的一个实例。本质上，</font></span><span style="font-size: 9pt; font-family: Courier; color: rgb(0,0,0)"><font size="9pt" face="Courier" color="rgb(0,0,0)">object()</font></span><span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">是对传入的对象执行了一次浅复制。</font></span>
    </div>
  </body>
</html></richcontent>
<node TEXT="function object(obj) {&#xa; function F() {}&#xa; F.prototype = obj;&#xa; return new F();&#xa;}&#xa;&#xa;let person = {&#xa; name: &quot;小朋友&quot;,&#xa; friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#xa;};&#xa;&#xa;let person2 = object(person)&#xa;person2.name=&apos;老朋友&apos;；&#xa;..." ID="ID_443616157" CREATED="1690562807706" MODIFIED="1690727978882"/>
</node>
<node TEXT="Object.create(对象,额外属性)" ID="ID_1706811375" CREATED="1690562833186" MODIFIED="1690872143151">
<node TEXT="let person = {&#xa; name: &quot;小朋友&quot;,&#xa; friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#xa;};&#xa;&#xa;let person2 = Object.create(person, {&#xa;    name: {&#xa;           value: &quot;老朋友&quot;&#xa;     }&#xa;})&#xa;person2.sex=&apos;man&apos;；&#xa;..." ID="ID_1656153661" CREATED="1690562875770" MODIFIED="1690872099512"/>
</node>
</node>
<node TEXT="寄生式继承" FOLDED="true" ID="ID_1659049659" CREATED="1690728165807" MODIFIED="1690728185527">
<node TEXT="function createAnother(obj){&#xa;     // 通过调用函数创建一个新对象&#xa;     let clone = object(obj);&#xa;     // 以某种方式增强这个对象&#xa;     clone.sayHi = function() {&#xa;         console.log(&quot;hi&quot;);&#xa;     };&#xa;     return clone; // 返回这个对象&#xa;}" ID="ID_1779684508" CREATED="1690728259596" MODIFIED="1690728383635"/>
</node>
<node TEXT="寄生式组合继承" FOLDED="true" POSITION="bottom_or_right" ID="ID_1119959930" CREATED="1690563051832" MODIFIED="1690563053637">
<node TEXT="function inheritPrototype(subType, superType) {&#xa;    // 创建对象&#xa;    let prototype = Object.create(superType.prototype);&#xa;    // 增强对象&#xa;     prototype.constructor = subType;&#xa;    // 赋值对象&#xa;     subType.prototype = prototype;&#xa;}" ID="ID_787346184" CREATED="1690563074765" MODIFIED="1690729236436"/>
<node TEXT="//父构造方法与原型&#xa;function Father(name) {&#xa; this.name = name;&#xa; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#xa;}&#xa;&#xa;Father.prototype.sayName = function() {&#xa; console.log(this.name);&#xa;};" ID="ID_1962496820" CREATED="1690563081551" MODIFIED="1690729171977"/>
<node TEXT="//子构造方法&#xa;function SubType(name, age) {&#xa;    SuperType.call(this, name);&#xa;    this.age = age;&#xa;}" ID="ID_551758474" CREATED="1690563095202" MODIFIED="1690729182526"/>
<node TEXT="inheritPrototype(SubType, SuperType);" ID="ID_114941588" CREATED="1690728827371" MODIFIED="1690728830870"/>
<node TEXT="SubType.prototype.sayAge = function() { &#xd;&#xa; console.log(this.age); &#xd;&#xa;};" ID="ID_32850749" CREATED="1690728837798" MODIFIED="1690728839430"/>
</node>
</node>
<node TEXT="类" FOLDED="true" ID="ID_329375469" CREATED="1690476065331" MODIFIED="1690478214953">
<node TEXT="类定义" FOLDED="true" ID="ID_360412350" CREATED="1690563214892" MODIFIED="1690563216169">
<node TEXT=" 类声明" ID="ID_1236182487" CREATED="1690563231690" MODIFIED="1690563233707">
<node TEXT="class Person {}" ID="ID_247508290" CREATED="1690563255174" MODIFIED="1690563256486"/>
</node>
<node TEXT=" 类表达式" ID="ID_599847679" CREATED="1690563249449" MODIFIED="1690563250902">
<node TEXT="const Animal = class {};" ID="ID_531878092" CREATED="1690563260930" MODIFIED="1690563262370"/>
</node>
<node TEXT="区别" ID="ID_1455180320" CREATED="1690563292146" MODIFIED="1690563295280">
<node TEXT="虽然函数声明可以提升，但类定义都不可以提升使用" ID="ID_1853718062" CREATED="1690563295282" MODIFIED="1690939815575"/>
<node TEXT="函数受函数作用域限制，而类受块作用域限制" ID="ID_1300571608" CREATED="1690563305086" MODIFIED="1690563307164"/>
</node>
<node TEXT="命名规则" ID="ID_1593587432" CREATED="1690563363504" MODIFIED="1690563368279">
<node TEXT="与变量命名相同，但是首字母大写（驼峰命名）" ID="ID_202399001" CREATED="1690563368281" MODIFIED="1690563388365"/>
</node>
</node>
<node TEXT="类的构成" FOLDED="true" ID="ID_928323348" CREATED="1690563320456" MODIFIED="1690563355644"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <div>
      <span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。 </font></span>
    </div>
    <div>
      <span style="font-size: 9.48pt; font-family: FZShuSong-Z01S; color: rgb(0,0,0)"><font size="9.48pt" face="FZShuSong-Z01S" color="rgb(0,0,0)">空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行</font></span>
    </div>
  </body>
</html></richcontent>
<node TEXT="// 空类定义，有效 &#xd;&#xa;class Foo {} &#xd;&#xa;// 有构造函数的类，有效&#xd;&#xa;class Bar { &#xd;&#xa; constructor() {} &#xd;&#xa;} &#xd;&#xa;// 有获取函数的类，有效&#xd;&#xa;class Baz { &#xd;&#xa; get myBaz() {} &#xd;&#xa;} &#xd;&#xa;// 有静态方法的类，有效&#xd;&#xa;class Qux { &#xd;&#xa; static myQux() {} &#xd;&#xa;}" ID="ID_1160250134" CREATED="1690563424583" MODIFIED="1690563426788"/>
</node>
<node TEXT="实例、原型和类成员" FOLDED="true" ID="ID_469468107" CREATED="1690563610456" MODIFIED="1690563612057">
<node TEXT="实例上的成员" FOLDED="true" ID="ID_681450926" CREATED="1690730919893" MODIFIED="1690730965173">
<node TEXT="在构造函数constructor中添加成员" ID="ID_1783661987" CREATED="1690730988673" MODIFIED="1690731004684">
<node TEXT="class Person { &#xd;&#xa; constructor() { &#xd;&#xa; // 这个例子先使用对象包装类型定义一个字符串&#xd;&#xa; // 为的是在下面测试两个对象的相等性&#xd;&#xa; this.name = new String(&apos;Jack&apos;); &#xd;&#xa; this.sayName = () =&gt; console.log(this.name); &#xd;&#xa; this.nicknames = [&apos;Jake&apos;, &apos;J-Dog&apos;] &#xd;&#xa; } &#xd;&#xa;}" ID="ID_1106678019" CREATED="1690731218834" MODIFIED="1690731220634"/>
</node>
</node>
<node TEXT="原型上的成员" FOLDED="true" ID="ID_148060839" CREATED="1690730920867" MODIFIED="1690730977761">
<node TEXT="在类块中定义的所有内容都会定义在类的原型上" FOLDED="true" ID="ID_976879916" CREATED="1690731018374" MODIFIED="1690731019513">
<node TEXT="class Person{&#xa; locate() {&#xa;     console.log(&apos;prototype&apos;);&#xa; }&#xa;}" ID="ID_1384077659" CREATED="1690731167411" MODIFIED="1690731190938"/>
</node>
<node TEXT="不能在类块中给原型添加原始值或对象作为成员数据" FOLDED="true" ID="ID_1093223428" CREATED="1690731032046" MODIFIED="1690731033963">
<node TEXT="class Person { &#xd;&#xa; name: &apos;Jake&apos; &#xd;//错误&#xa;}" ID="ID_635206248" CREATED="1690731200173" MODIFIED="1690731206623"/>
</node>
<node TEXT="类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键" FOLDED="true" ID="ID_1615213820" CREATED="1690731077513" MODIFIED="1690731085374">
<node TEXT="class Person {&#xa; stringKey() {&#xa; console.log(&apos;invoked stringKey&apos;);&#xa; }&#xa; [symbolKey]() {&#xa; console.log(&apos;invoked symbolKey&apos;);&#xa; }&#xa; [&apos;computed&apos; + &apos;Key&apos;]() {&#xa; console.log(&apos;invoked computedKey&apos;);&#xa; }&#xa;}" ID="ID_1905858883" CREATED="1690731143534" MODIFIED="1690731150184"/>
</node>
<node TEXT="类定义也支持获取和设置访问器。语法与行为跟普通对象一样" FOLDED="true" ID="ID_935389629" CREATED="1690731096655" MODIFIED="1690731119410">
<node TEXT="set name(newName) { &#xd;&#xa; this.name_ = newName; &#xd;&#xa; }" ID="ID_1025695150" CREATED="1690731124374" MODIFIED="1690731126238"/>
<node TEXT="get name() { &#xd;&#xa; return this.name_; &#xd;&#xa; }" ID="ID_1495061150" CREATED="1690731130932" MODIFIED="1690731132426"/>
</node>
</node>
<node TEXT="类本身的成员" FOLDED="true" ID="ID_1154716359" CREATED="1690730921357" MODIFIED="1690903779890" VGAP_QUANTITY="3 pt">
<node TEXT="静态成员每个类上只能有一个。静态类成员在类定义中使用 static 关键字作为前缀。在静态成员中，this 引用类自身" FOLDED="true" ID="ID_93957021" CREATED="1690903779290" MODIFIED="1690903976034">
<node TEXT="class Person { &#xd;&#xa; constructor() { &#xd;&#xa; // 添加到 this 的所有内容都会存在于不同的实例上&#xd;&#xa; this.locate = () =&gt; console.log(&apos;instance&apos;, this); &#xd;&#xa; } &#xd;&#xa; // 定义在类的原型对象上&#xd;&#xa; locate() { &#xd;&#xa; console.log(&apos;prototype&apos;, this); &#xd;&#xa; } &#xd;&#xa; // 定义在类本身上&#xd;&#xa; static locate() { &#xd;&#xa; console.log(&apos;class&apos;, this); &#xd;&#xa; } &#xd;&#xa;}" ID="ID_1091030357" CREATED="1690903958462" MODIFIED="1690903961884"/>
</node>
<node TEXT="静态类方法非常适合作为实例工厂" FOLDED="true" ID="ID_1634158648" CREATED="1690905142410" MODIFIED="1690905145297">
<node TEXT="static create() { &#xd;&#xa; // 使用随机年龄创建并返回一个 Person 实例&#xd;&#xa; return new Person(Math.floor(Math.random()*100)); &#xd;&#xa; }" ID="ID_1905465621" CREATED="1690905159384" MODIFIED="1690905160917"/>
</node>
</node>
<node TEXT="非函数原型和类成员" FOLDED="true" ID="ID_1211776580" CREATED="1690732737777" MODIFIED="1690732739378">
<node TEXT="// 在类上定义数据成员&#xd;&#xa;Person.greeting = &apos;My name is&apos;;" ID="ID_717855466" CREATED="1690732762264" MODIFIED="1690732773303"/>
<node TEXT="// 在原型上定义数据成员&#xd;&#xa;Person.prototype.name = &apos;Jake&apos;;" ID="ID_65276304" CREATED="1690732773548" MODIFIED="1690732775072"/>
<node TEXT="但在类定义外部，可以手动添加" ID="ID_960134669" CREATED="1690732786887" MODIFIED="1690732788356"/>
</node>
<node TEXT="迭代器与生成器方法" FOLDED="true" ID="ID_678308537" CREATED="1690732821903" MODIFIED="1690732823335">
<node TEXT="class Person { &#xd;&#xa; // 在原型上定义生成器方法&#xd;&#xa; *createNicknameIterator() { &#xd;&#xa; yield &apos;Jack&apos;; &#xd;&#xa; yield &apos;Jake&apos;; &#xd;&#xa; yield &apos;J-Dog&apos;; &#xd;&#xa; } &#xd;&#xa; // 在类上定义生成器方法&#xd;&#xa; static *createJobIterator() { &#xd;&#xa; yield &apos;Butcher&apos;; &#xd;&#xa; yield &apos;Baker&apos;; &#xd;&#xa; yield &apos;Candlestick maker&apos;; &#xd;&#xa; } &#xd;&#xa;}" ID="ID_1128278494" CREATED="1690732843392" MODIFIED="1690732846260"/>
<node TEXT=" constructor() {&#xa; this.nicknames = [&apos;Jack&apos;, &apos;Jake&apos;, &apos;J-Dog&apos;];&#xa; }&#xa;//迭代器&#xa; *[Symbol.iterator]() {&#xa; yield *this.nicknames.entries();&#xa; }&#xa;}" ID="ID_1938876877" CREATED="1690732855280" MODIFIED="1690732871192"/>
</node>
</node>
<node TEXT="类继承" ID="ID_404036823" CREATED="1690563824445" MODIFIED="1690563828358">
<node TEXT="继承基础" FOLDED="true" ID="ID_1701673399" CREATED="1690904274972" MODIFIED="1690904288957">
<node TEXT="ES6 类支持单继承" ID="ID_1808660032" CREATED="1690904297623" MODIFIED="1690904299234"/>
<node TEXT="使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。" ID="ID_1263516092" CREATED="1690904304661" MODIFIED="1690904306100"/>
<node TEXT="// 继承类&#xa;class Father extends Son {}" ID="ID_1273405792" CREATED="1690904338718" MODIFIED="1690904363441"/>
<node TEXT="function Father(){}&#xa;// 继承普通构造函数&#xa;class Father extends Son {}" ID="ID_909484118" CREATED="1690904347383" MODIFIED="1690904382800"/>
</node>
<node TEXT=" 构造函数" FOLDED="true" ID="ID_1846294135" CREATED="1690904440700" MODIFIED="1690904442382">
<node TEXT="constructor()" ID="ID_1056833260" CREATED="1690904993936" MODIFIED="1690904995232">
<node TEXT="class Vehicle {&#xa; constructor() {&#xa; this.hasEngine = true;&#xa; }&#xa;}&#xa;&#xa;class Bus extends Vehicle { &#xd;&#xa; constructor() { &#xd;&#xa; // 不要在调用 super()之前引用 this，否则会抛出 ReferenceError &#xd;&#xa; super(); // 相当于 super.constructor() &#xd;&#xa; console.log(this instanceof Vehicle); // true &#xd;&#xa; console.log(this); // Bus { hasEngine: true } &#xd;&#xa; } &#xd;&#xa;}" ID="ID_1601721180" CREATED="1690905002987" MODIFIED="1690905017248"/>
</node>
</node>
<node TEXT="super()" FOLDED="true" ID="ID_1239150117" CREATED="1690904453902" MODIFIED="1690904455604">
<node TEXT="派生类(子类)的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅&#xa;限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数" ID="ID_702996514" CREATED="1690904492555" MODIFIED="1690945191749"/>
<node TEXT="在静态方法中可以通过 super 调用继承的类上定义的静态方法：" ID="ID_265885460" CREATED="1690905040252" MODIFIED="1690905042288"/>
<node TEXT="注意事项" ID="ID_1559284319" CREATED="1690905075288" MODIFIED="1690905401965">
<node TEXT="super 只能在派生类构造函数和静态方法中使用。" ID="ID_1997654547" CREATED="1690905401968" MODIFIED="1690905403999"/>
<node TEXT="不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法" ID="ID_930588297" CREATED="1690905425385" MODIFIED="1690905426926"/>
<node TEXT="调用 super()会调用父类构造函数，并将返回的实例赋值给 this。" ID="ID_157577160" CREATED="1690905433429" MODIFIED="1690905434826"/>
<node TEXT="super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。" ID="ID_757586737" CREATED="1690905451661" MODIFIED="1690905452982"/>
<node TEXT="如果没有定义类构造函数，在实例化派生类时会调用 super()，而且会传入所有传给派生类的参数" ID="ID_183333420" CREATED="1690905462274" MODIFIED="1690946021289"/>
<node TEXT="在类构造函数中，不能在调用 super()之前引用 this。" ID="ID_245022672" CREATED="1690905472685" MODIFIED="1690905474134"/>
<node TEXT="如果在派生类中显式定义了构造函数，则要么必须在其中调用 super()，要么必须在其中返回一个对象。" ID="ID_1514903791" CREATED="1690905493857" MODIFIED="1690946164494"/>
</node>
</node>
<node TEXT="抽象基类" ID="ID_1632741416" CREATED="1690905513888" MODIFIED="1690905515662">
<node TEXT="可供其他类继承，但本身不会被实例化的类就是基类" ID="ID_543064838" CREATED="1690908064405" MODIFIED="1690908085841"/>
<node TEXT="实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化" FOLDED="true" ID="ID_1796441534" CREATED="1690908128697" MODIFIED="1690908130299">
<node TEXT="class Animal{&#xa;            //不能被实例话对象&#xa;            constructor(){&#xa;                //console.log(new.target)&#xa;                //判断是否正在执行实例话操作&#xa;                if(new.target === Animal){&#xa;                    throw new Error(&apos;当前对象不可以被实例话操作&apos;);&#xa;                }&#xa;&#xa;                //添加抽象类中成员规则判断&#xa;                if(!this.run){&#xa;                    throw new Error(&apos;未能实现抽象基类中的run属性&apos;);&#xa;                }&#xa;&#xa;                if(!this.eye){&#xa;                    throw new Error(&apos;未能实现抽象基类中的eye属性&apos;);&#xa;                }&#xa;&#xa;            }&#xa;        }" ID="ID_1780384766" CREATED="1690908180418" MODIFIED="1690957328813"/>
</node>
<node TEXT="在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法" FOLDED="true" ID="ID_1106989424" CREATED="1690908220372" MODIFIED="1690908222670">
<node TEXT="class Animal{&#xa;            //不能被实例话对象&#xa;            constructor(){&#xa;                //console.log(new.target)&#xa;                //判断是否正在执行实例话操作&#xa;                if(new.target === Animal){&#xa;                    throw new Error(&apos;当前对象不可以被实例话操作&apos;);&#xa;                }&#xa;&#xa;                //添加抽象类中成员规则判断&#xa;                if(!this.run){&#xa;                    throw new Error(&apos;未能实现抽象基类中的run属性&apos;);&#xa;                }&#xa;&#xa;                if(!this.eye){&#xa;                    throw new Error(&apos;未能实现抽象基类中的eye属性&apos;);&#xa;                }&#xa;&#xa;            }&#xa;        }" ID="ID_1236224220" CREATED="1690908228352" MODIFIED="1690957333172"/>
</node>
</node>
<node TEXT="继承内置类型" FOLDED="true" POSITION="bottom_or_right" ID="ID_1162676129" CREATED="1690908236721" MODIFIED="1690908240299">
<node TEXT="     //扩展数组类型（我做的数组）&#xa;      class MyArray extends Array{&#xa;            //功能扩展&#xa;            getLast(){&#xa;                return this[this.length-1]&#xa;            }&#xa;&#xa;        }" ID="ID_406642042" CREATED="1690908248020" MODIFIED="1690957297205"/>
</node>
<node TEXT=" 类混入/多继承" FOLDED="true" POSITION="bottom_or_right" ID="ID_1179292858" CREATED="1690908410251" MODIFIED="1690908421191">
<node TEXT="Object.assign()方法是为了混入对象行为而设计的。" ID="ID_1542377777" CREATED="1690908484448" MODIFIED="1690908487388"/>
<node TEXT="自定义mix函数" FOLDED="true" ID="ID_1351793469" CREATED="1690908566139" MODIFIED="1690908578941">
<node TEXT="class Vehicle {} &#xd;&#xa;let FooMixin = (Superclass) =&gt; class extends Superclass { &#xd;&#xa; foo() { &#xd;&#xa; console.log(&apos;foo&apos;); &#xd;&#xa; } &#xd;&#xa;}; &#xd;&#xa;let BarMixin = (Superclass) =&gt; class extends Superclass { &#xd;&#xa; bar() { &#xd;&#xa; console.log(&apos;bar&apos;); &#xd;&#xa; } &#xd;&#xa;}; &#xd;&#xa;let BazMixin = (Superclass) =&gt; class extends Superclass { &#xd;&#xa; baz() { &#xd;&#xa; console.log(&apos;baz&apos;); &#xd;&#xa; } &#xd;&#xa;};" ID="ID_591456268" CREATED="1690908580816" MODIFIED="1690908582578"/>
<node TEXT="function mix(BaseClass, ...Mixins) { &#xd;&#xa; return Mixins.reduce((accumulator, current) =&gt; current(accumulator), BaseClass); &#xd;&#xa;} &#xd;&#xa;class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {}" FOLDED="true" ID="ID_404624451" CREATED="1690908592574" MODIFIED="1690908594178">
<node TEXT="" ID="ID_1061948603" CREATED="1690908594571" MODIFIED="1690908594571"/>
</node>
</node>
</node>
</node>
</node>
<node TEXT="js对象原理图" FOLDED="true" ID="ID_1135770333" CREATED="1690563139634" MODIFIED="1690766110654" VGAP_QUANTITY="3 pt">
<node TEXT="构造方法/原型/实例图" ID="ID_1308062744" CREATED="1690713377625" MODIFIED="1690766110654"/>
<node TEXT="对象关系图" ID="ID_1723603122" CREATED="1690713378247" MODIFIED="1690713407733"/>
<node TEXT="对象原型链" ID="ID_1601588002" CREATED="1690713378913" MODIFIED="1690713424137"/>
</node>
</node>
<node TEXT="JSON语法" FOLDED="true" POSITION="top_or_left" ID="ID_714597785" CREATED="1687770563301" MODIFIED="1687770567381">
<node TEXT="stringify" ID="ID_528014063" CREATED="1692152019215" MODIFIED="1692152021232">
<node TEXT="将JS对象转换为字符串格式，json格式" ID="ID_1593348389" CREATED="1692152021846" MODIFIED="1692152038704"/>
</node>
<node TEXT="parse" POSITION="top_or_left" ID="ID_982685242" CREATED="1692152042070" MODIFIED="1692152049303">
<node TEXT="将JSON格式字符串，解析成JS中的对象" ID="ID_813110487" CREATED="1692152055166" MODIFIED="1692152074856"/>
</node>
</node>
<node TEXT="内置对象" FOLDED="true" POSITION="bottom_or_right" ID="ID_1937572167" CREATED="1687770638311" MODIFIED="1687770644391">
<node TEXT="基本引用类型" FOLDED="true" ID="ID_352439196" CREATED="1687770647278" MODIFIED="1687770653744">
<node TEXT="String对象" FOLDED="true" ID="ID_1859460806" CREATED="1687770670602" MODIFIED="1687770702732">
<node TEXT="字符操作" FOLDED="true" ID="ID_1347149009" CREATED="1691078720735" MODIFIED="1691078723326">
<node TEXT="charAt()" ID="ID_1833934525" CREATED="1690826348266" MODIFIED="1691078414754">
<node TEXT="返回给定索引位置的字符，由传给方法的整数参数指定" ID="ID_1582282920" CREATED="1691078409681" MODIFIED="1691078411319"/>
</node>
<node TEXT="charCodeAt()" ID="ID_809879534" CREATED="1690826348266" MODIFIED="1691078500498">
<node TEXT="查看指定码元的字符编码" ID="ID_1854489390" CREATED="1691078427963" MODIFIED="1691078430997"/>
</node>
<node TEXT="codePointAt()" FOLDED="true" ID="ID_1214913099" CREATED="1690826348266" MODIFIED="1691078498054">
<node TEXT="接收 16 位码元的索引并返回该索引&#xd;&#xa;位置上的码点（code point）。码点是 Unicode 中一个字符的完整标识" ID="ID_1121117961" CREATED="1691078493661" MODIFIED="1691078495680"/>
</node>
</node>
<node TEXT="字符串包含方法" FOLDED="true" ID="ID_1651976729" CREATED="1691078896264" MODIFIED="1691078898264">
<node TEXT="includes()" ID="ID_1500083438" CREATED="1690826348267" MODIFIED="1691078955931">
<node TEXT="从字符串中搜索传入的字符串，并返回一个表示是否包含&#xa;的布尔值，检查整个字符串：" ID="ID_805559586" CREATED="1691078910511" MODIFIED="1691078947787"/>
</node>
<node TEXT="startsWith()" ID="ID_279630034" CREATED="1690826348270" MODIFIED="1691078959050">
<node TEXT="从字符串中搜索传入的字符串，并返回一个表示是否包含&#xa;的布尔值，检查开始于索引 0 的匹配项" ID="ID_547171432" CREATED="1691078911669" MODIFIED="1691078926555"/>
</node>
<node TEXT="endsWith()" ID="ID_865537382" CREATED="1690826348266" MODIFIED="1691078963293">
<node TEXT="从字符串中搜索传入的字符串，并返回一个表示是否包含&#xa;的布尔值，endsWith()检查开始于索&#xd;&#xa;引(string.length - substring.length)的匹配项" ID="ID_994969632" CREATED="1691078913587" MODIFIED="1691078933667"/>
</node>
</node>
<node TEXT="字符串位置方法" FOLDED="true" ID="ID_1902588293" CREATED="1691078836253" MODIFIED="1691078839850">
<node TEXT="indexOf（）" ID="ID_1741664216" CREATED="1690826348267" MODIFIED="1691078814841">
<node TEXT="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）,从头开始匹配" ID="ID_443771408" CREATED="1691078781673" MODIFIED="1691078804271"/>
</node>
<node TEXT="lastIndexOf（）" ID="ID_1474106490" CREATED="1690826348267" MODIFIED="1691078817560">
<node TEXT="从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）,从结尾开始匹配" ID="ID_81658508" CREATED="1691078804519" MODIFIED="1691078811382"/>
</node>
</node>
<node TEXT="字符串填充" FOLDED="true" ID="ID_1269524893" CREATED="1691079491112" MODIFIED="1691079497480">
<node TEXT="padEnd()" ID="ID_32440907" CREATED="1690826348268" MODIFIED="1691079142314">
<node TEXT="复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件," ID="ID_1423213627" CREATED="1691079108063" MODIFIED="1691079136552"/>
</node>
<node TEXT="padStart()" ID="ID_1482903811" CREATED="1690826348269" MODIFIED="1691079145141">
<node TEXT="复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件" ID="ID_1550972784" CREATED="1691079099459" MODIFIED="1691079106889"/>
</node>
<node TEXT="repeat()" POSITION="bottom_or_right" ID="ID_1303210985" CREATED="1690826348269" MODIFIED="1691129915724">
<node TEXT="字符串重复" ID="ID_1701238074" CREATED="1691129915727" MODIFIED="1691129917421"/>
</node>
</node>
<node TEXT="大小写转换" FOLDED="true" ID="ID_1461885616" CREATED="1691079173768" MODIFIED="1691079181094">
<node TEXT="toLocaleLowerCase()" ID="ID_784284594" CREATED="1690826348271" MODIFIED="1691079270362">
<node TEXT="转换为小写字母,针对特殊语言如土耳其语规则" ID="ID_410370961" CREATED="1691079231717" MODIFIED="1691079258196"/>
</node>
<node TEXT="toLocaleUpperCase()" ID="ID_642993548" CREATED="1690826348271" MODIFIED="1691079273872">
<node TEXT="转换为大写字母,针对特殊语言如土耳其语规则" ID="ID_411693500" CREATED="1691079233120" MODIFIED="1691079251712"/>
</node>
<node TEXT="toUpperCase()" ID="ID_1469377779" CREATED="1690826348272" MODIFIED="1691079225978">
<node TEXT="转换为大写字母" ID="ID_455749183" CREATED="1691079204611" MODIFIED="1691079214270"/>
</node>
<node TEXT="toLowerCase()" ID="ID_442385031" CREATED="1690826348271" MODIFIED="1691079227807">
<node TEXT="转换为小写字母" ID="ID_587137218" CREATED="1691079215171" MODIFIED="1691079219728"/>
</node>
</node>
<node TEXT="trim()方法" FOLDED="true" ID="ID_463683394" CREATED="1691078985844" MODIFIED="1691078988090">
<node TEXT="trim()" ID="ID_54853420" CREATED="1690826348272" MODIFIED="1691079023232">
<node TEXT="会创建字符串的一个副本，删除前、&#xd;&#xa;后所有空格符，再返回结果" ID="ID_186419681" CREATED="1691079018527" MODIFIED="1691079020363"/>
</node>
<node TEXT="trimLeft()" ID="ID_1428838929" CREATED="1690826348272" MODIFIED="1691079036700">
<node TEXT="用于从字符串左侧清理空格符" ID="ID_792189986" CREATED="1691079037411" MODIFIED="1691129651157"/>
</node>
<node TEXT="trimRight()" ID="ID_1561461340" CREATED="1690826348272" MODIFIED="1691079054866">
<node TEXT="用于从字符串右侧清理空格符" ID="ID_1337938330" CREATED="1691079043869" MODIFIED="1691129654134"/>
</node>
<node TEXT="trimStart()" ID="ID_406183544" CREATED="1690826348273" MODIFIED="1691129629929">
<node TEXT="用于从字符串开始清理空格符" ID="ID_1149029936" CREATED="1691079037411" MODIFIED="1691079042586"/>
</node>
<node TEXT="trimEnd()" ID="ID_545120463" CREATED="1690826348272" MODIFIED="1691129633763">
<node TEXT="用于从字符串末尾清理空格符" ID="ID_1628026311" CREATED="1691079043869" MODIFIED="1691079050812"/>
</node>
</node>
<node TEXT="正则相关" ID="ID_808045948" CREATED="1691079417410" MODIFIED="1691079424364">
<node TEXT="match()" ID="ID_582665125" CREATED="1690826348268" MODIFIED="1691079432824">
<node TEXT="进行正则匹配" ID="ID_334731389" CREATED="1691079651647" MODIFIED="1691079657678"/>
</node>
<node TEXT="matchAll()" ID="ID_750597578" CREATED="1690826348268" MODIFIED="1691079434300">
<node TEXT="" ID="ID_1246154124" CREATED="1691133843260" MODIFIED="1691133843260"/>
</node>
<node TEXT="search()" ID="ID_1403054290" CREATED="1690826348269" MODIFIED="1691079435388">
<node TEXT="返回指定字符/正则在字符串中的位置" ID="ID_1306346565" CREATED="1691079630211" MODIFIED="1691079649700"/>
</node>
<node TEXT="replace()" POSITION="bottom_or_right" ID="ID_178929561" CREATED="1690826348269" MODIFIED="1691079571470">
<node TEXT="进行正则/字符串替换" ID="ID_1532284775" CREATED="1691079566892" MODIFIED="1691079583666"/>
</node>
<node TEXT="replaceAll（）" POSITION="bottom_or_right" ID="ID_1788723953" CREATED="1690826348269" MODIFIED="1691216007288">
<node TEXT="进行正则匹配，替换指定的所有数据" ID="ID_664153578" CREATED="1691215948976" MODIFIED="1691215965711"/>
</node>
<node TEXT="split（）" POSITION="bottom_or_right" ID="ID_538376527" CREATED="1690826348270" MODIFIED="1691216004321">
<node TEXT="字符串切割函数" ID="ID_1712533083" CREATED="1691215996783" MODIFIED="1691216001091"/>
</node>
</node>
<node TEXT="字符串操作方法" ID="ID_678568215" CREATED="1691078678316" MODIFIED="1691078680223">
<node TEXT="slice（）" ID="ID_1387722732" CREATED="1690826348269" MODIFIED="1691078643994">
<node TEXT="调用它们的字符串的一个子字符串" ID="ID_390431695" CREATED="1691078643999" MODIFIED="1691078645550"/>
</node>
<node TEXT="substr（）" ID="ID_1810208024" CREATED="1690826348270" MODIFIED="1691078633312">
<node TEXT="调用它们的字符串的一个子字符串" ID="ID_178331642" CREATED="1691078627053" MODIFIED="1691078628674"/>
</node>
<node TEXT="substring（）" ID="ID_1414922659" CREATED="1690826348270" MODIFIED="1691078636201">
<node TEXT="调用它们的字符串的一个子字符串" ID="ID_298512021" CREATED="1691078628975" MODIFIED="1691078630835"/>
</node>
<node TEXT="concat()" POSITION="bottom_or_right" ID="ID_882223050" CREATED="1690826348266" MODIFIED="1691078504097">
<node TEXT="用于将一个或多个字符串拼接成一个新字符串" ID="ID_893943230" CREATED="1691078595922" MODIFIED="1691078599730"/>
</node>
</node>
</node>
<node TEXT="Boolean对象" FOLDED="true" ID="ID_1108067414" CREATED="1687770704351" MODIFIED="1687770708222">
<node TEXT="无" ID="ID_117327010" CREATED="1690826356612" MODIFIED="1690826361479"/>
</node>
<node TEXT="Number对象" FOLDED="true" ID="ID_447816446" CREATED="1687770709425" MODIFIED="1687770713003">
<node TEXT="toExponential(小数位数)" ID="ID_219225427" CREATED="1690826471722" MODIFIED="1691074067032">
<node TEXT="返回以科学记数法（也称为指数记数法）表&#xd;&#xa;示的数值字符串" ID="ID_1119175678" CREATED="1691074040556" MODIFIED="1691074042151"/>
</node>
<node TEXT="toFixed(小数位数)" ID="ID_921862043" CREATED="1690826471723" MODIFIED="1691074076690">
<node TEXT="返回包含指定小数点位数的数值字符串,可以表示有 0~20 个小数位的数值" ID="ID_1558633812" CREATED="1691073993620" MODIFIED="1691074025365"/>
</node>
<node TEXT="toPrecision(数字的总位数（不包含指数）)" ID="ID_849077430" CREATED="1690826471724" MODIFIED="1691074169523">
<node TEXT="会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式" ID="ID_1801338520" CREATED="1691074103665" MODIFIED="1691074108642"/>
</node>
<node TEXT="继承自Object" FOLDED="true" ID="ID_522145791" CREATED="1691074125681" MODIFIED="1691074870954">
<node TEXT="constructor" POSITION="bottom_or_right" ID="ID_1366167455" CREATED="1690826471722" MODIFIED="1690826471722"/>
<node TEXT="toLocaleString" POSITION="bottom_or_right" ID="ID_1916063466" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="toString" POSITION="bottom_or_right" ID="ID_1209795482" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="valueOf" POSITION="bottom_or_right" ID="ID_1551367763" CREATED="1690826471724" MODIFIED="1690826471724"/>
</node>
</node>
<node TEXT="Global对象（固有对象）&#xa;需要宿主去实现（window）" FOLDED="true" ID="ID_453015011" CREATED="1687770722108" MODIFIED="1691111146770">
<node TEXT="encodeURI()" ID="ID_817417418" CREATED="1691074201989" MODIFIED="1691074203167">
<node TEXT="用于对整个 URI 进行编码,不会编码属于 URL 组件的特殊字符" ID="ID_1953875801" CREATED="1691074254960" MODIFIED="1691080090442"/>
</node>
<node TEXT="encodeURIComponent()" ID="ID_1774935074" CREATED="1691074214763" MODIFIED="1691074216060">
<node TEXT="用于编码 URI 中单独的组件" ID="ID_792355884" CREATED="1691074267156" MODIFIED="1691074271806"/>
</node>
<node TEXT="decodeURI()" ID="ID_1878466927" CREATED="1691074361029" MODIFIED="1691074362485">
<node TEXT="用于对整个 URI 进行解码" ID="ID_127059841" CREATED="1691074845555" MODIFIED="1691074851730"/>
</node>
<node TEXT="decodeURIComponent()" ID="ID_471224768" CREATED="1691074368264" MODIFIED="1691074371738">
<node TEXT="用于解码 URI 中单独的组件" ID="ID_973770903" CREATED="1691074854735" MODIFIED="1691074860282"/>
</node>
<node TEXT=" eval()" ID="ID_915520601" CREATED="1691074388419" MODIFIED="1691074389912">
<node TEXT="将字符串当作js代码执行" ID="ID_738800938" CREATED="1691074532837" MODIFIED="1691074541058"/>
</node>
<node TEXT="自带属性" FOLDED="true" ID="ID_1337826154" CREATED="1691074670754" MODIFIED="1691074677613">
<node TEXT="undefined 特殊值 undefined&#xa;NaN          特殊值 NaN&#xa;Infinity      特殊值 Infinity&#xa;Object       Object 的构造函数&#xa;Array         Array 的构造函数&#xa;Function    Function 的构造函数&#xa;Boolean     Boolean 的构造函数&#xa;String        String 的构造函数&#xa;Number    Number 的构造函数&#xa;Date          Date 的构造函数&#xa;RegExp     RegExp 的构造函数&#xa;Symbol      Symbol 的伪构造函数&#xa;Error         Error 的构造函数&#xa;EvalError    EvalError 的构造函数&#xa;RangeError RangeError 的构造函数&#xa;ReferenceError ReferenceError 的构造函数&#xa;SyntaxError SyntaxError 的构造函数&#xa;TypeError  TypeError 的构造函数&#xa;URIError     URIError 的构造函数" ID="ID_1292883472" CREATED="1691074695139" MODIFIED="1691074763703"/>
</node>
<node TEXT="isNaN()" ID="ID_534501783" CREATED="1691079873598" MODIFIED="1691079875236">
<node TEXT="j检测数据是否是NaN" ID="ID_1127548799" CREATED="1691080128130" MODIFIED="1691080136540"/>
</node>
<node TEXT="isFinite()" ID="ID_1479027417" CREATED="1691079879557" MODIFIED="1691079880843">
<node TEXT="用于检查其参数是否是无穷大,无穷大是false" ID="ID_1680265220" CREATED="1691079881134" MODIFIED="1691111521967"/>
</node>
<node TEXT="parseInt()" ID="ID_1296646414" CREATED="1691079884681" MODIFIED="1691079886054">
<node TEXT="强制转换为整形" ID="ID_1190458074" CREATED="1691080137474" MODIFIED="1691080143165"/>
</node>
<node TEXT="parseFloat()" ID="ID_70225348" CREATED="1691079890368" MODIFIED="1691079891767">
<node TEXT="强制转换为浮点型" ID="ID_825559985" CREATED="1691080144452" MODIFIED="1691080150540"/>
</node>
</node>
<node TEXT="Math对象（固有对象）" FOLDED="true" ID="ID_1680454661" CREATED="1687770732090" MODIFIED="1691111103633">
<node TEXT="自带属性" FOLDED="true" ID="ID_1589265304" CREATED="1691074814991" MODIFIED="1691074822767">
<node TEXT="E" ID="ID_1226819048" CREATED="1691076180507" MODIFIED="1691076201610">
<node TEXT="返回算术常量 e，即自然对数的底数（约等于2.718）" ID="ID_898112444" CREATED="1691076204760" MODIFIED="1691076206084"/>
</node>
<node TEXT="LN2" ID="ID_1417429395" CREATED="1691076193292" MODIFIED="1691076211668">
<node TEXT="返回 2 的自然对数（约等于0.693）。" ID="ID_531532603" CREATED="1691076217983" MODIFIED="1691076219170"/>
</node>
<node TEXT="LN10" ID="ID_383578639" CREATED="1691076193776" MODIFIED="1691076223859">
<node TEXT="返回 10 的自然对数（约等于2.302）" ID="ID_315401604" CREATED="1691076227594" MODIFIED="1691076228741"/>
</node>
<node TEXT="LOG2E" ID="ID_16733790" CREATED="1691076194165" MODIFIED="1691076234308">
<node TEXT="返回以 2 为底的 e 的对数（约等于 1.414）。" ID="ID_1123299805" CREATED="1691076194485" MODIFIED="1691076238804"/>
</node>
<node TEXT="LOG10E" ID="ID_430861139" CREATED="1691076194837" MODIFIED="1691076243776">
<node TEXT="返回以 10 为底的 e 的对数（约等于0.434）" ID="ID_902316518" CREATED="1691076247600" MODIFIED="1691076248791"/>
</node>
<node TEXT="PI" ID="ID_199457738" CREATED="1691076252515" MODIFIED="1691076253931">
<node TEXT="返回圆周率（约等于3.14159）。" ID="ID_776200142" CREATED="1691076256554" MODIFIED="1691076258025"/>
</node>
<node TEXT="SQRT1_2" ID="ID_1740621451" CREATED="1691076263621" MODIFIED="1691076265507">
<node TEXT="返回返回 2 的平方根的倒数（约等于 0.707）。" ID="ID_581947737" CREATED="1691076268814" MODIFIED="1691076270193"/>
</node>
<node TEXT="SQRT2" ID="ID_491084250" CREATED="1691076274029" MODIFIED="1691076275575">
<node TEXT="返回 2 的平方根（约等于 1.414）。" ID="ID_227788079" CREATED="1691076278797" MODIFIED="1691076280150"/>
</node>
</node>
<node TEXT="三角函数" FOLDED="true" ID="ID_1193189471" CREATED="1691076595322" MODIFIED="1691076597933">
<node TEXT="acos(x)" ID="ID_1388214884" CREATED="1691076322335" MODIFIED="1691076323677">
<node TEXT="返回 x 的反余弦值。" ID="ID_983789258" CREATED="1691076327026" MODIFIED="1691076328787"/>
</node>
<node TEXT="asin(x)" ID="ID_1257045131" CREATED="1691076341290" MODIFIED="1691076343319">
<node TEXT="返回 x 的反正弦值。" ID="ID_1091698980" CREATED="1691076346239" MODIFIED="1691076347358"/>
</node>
<node TEXT="atan(x)" ID="ID_875600040" CREATED="1691076351854" MODIFIED="1691076353355">
<node TEXT="以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。" ID="ID_1087407496" CREATED="1691076358104" MODIFIED="1691076359455"/>
</node>
<node TEXT="atan2(y,x)" ID="ID_1676310549" CREATED="1691076363971" MODIFIED="1691076365610">
<node TEXT="返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。" ID="ID_1576010041" CREATED="1691076369970" MODIFIED="1691076371418"/>
</node>
<node TEXT="cos(x)" ID="ID_887479731" CREATED="1691076393486" MODIFIED="1691076396805">
<node TEXT="返回数的余弦。" ID="ID_1286783878" CREATED="1691076401313" MODIFIED="1691076402554"/>
</node>
<node TEXT="tan(x)" POSITION="bottom_or_right" ID="ID_385362966" CREATED="1691076548066" MODIFIED="1691076549757">
<node TEXT="返回角的正切。" ID="ID_1674930603" CREATED="1691076555972" MODIFIED="1691076566580"/>
</node>
<node TEXT="sin(x)" POSITION="bottom_or_right" ID="ID_1865472817" CREATED="1691076517324" MODIFIED="1691076522420">
<node TEXT="返回数的正弦。" ID="ID_278415744" CREATED="1691076522424" MODIFIED="1691076523798"/>
</node>
</node>
<node TEXT="abs(x)" ID="ID_1077295982" CREATED="1691076150092" MODIFIED="1691076313584">
<node TEXT="返回 x 的绝对值。" ID="ID_999181026" CREATED="1691076316887" MODIFIED="1691076318089"/>
</node>
<node TEXT="log(x)" ID="ID_891741135" CREATED="1691076441988" MODIFIED="1691076446526">
<node TEXT="返回数的自然对数（底为e）。" ID="ID_848155858" CREATED="1691076450144" MODIFIED="1691076451348"/>
</node>
<node TEXT="exp(x)" ID="ID_1136446491" CREATED="1691076407749" MODIFIED="1691076409705">
<node TEXT="返回 Ex 的指数。" ID="ID_1902923527" CREATED="1691076413229" MODIFIED="1691076414867"/>
</node>
<node TEXT="floor(x)" ID="ID_450276519" CREATED="1691076425953" MODIFIED="1691076427751">
<node TEXT="对 x 进行下舍入。" ID="ID_237232420" CREATED="1691076431336" MODIFIED="1691076432734"/>
</node>
<node TEXT="ceil(x)" ID="ID_1918044172" CREATED="1691076379054" MODIFIED="1691076381169">
<node TEXT="对数进行上舍入。" ID="ID_1783719783" CREATED="1691076383975" MODIFIED="1691076385234"/>
</node>
<node TEXT="max(x,y,z,...,n)" ID="ID_81786292" CREATED="1691076458196" MODIFIED="1691076461581">
<node TEXT="返回 x,y,z,...,n 中的最高值。" ID="ID_820797824" CREATED="1691076465463" MODIFIED="1691076466894"/>
</node>
<node TEXT="min(x,y,z,...,n)" ID="ID_1270345800" CREATED="1691076470772" MODIFIED="1691076475649">
<node TEXT="返回 x,y,z,...,n中的最低值。" ID="ID_1473889766" CREATED="1691076475650" MODIFIED="1691076477122"/>
</node>
<node TEXT="pow(x,y)" ID="ID_381362388" CREATED="1691076481315" MODIFIED="1691076483032">
<node TEXT="返回 x 的 y 次幂。" ID="ID_1109763242" CREATED="1691076486531" MODIFIED="1691076487826"/>
</node>
<node TEXT="random()" ID="ID_1117659058" CREATED="1691076491694" MODIFIED="1691076493296">
<node TEXT="返回 0 ~ 1 之间的随机数" ID="ID_1022679455" CREATED="1691076496427" MODIFIED="1691076497702"/>
</node>
<node TEXT="round(x)" ID="ID_1834458614" CREATED="1691076504155" MODIFIED="1691076505744">
<node TEXT="把数四舍五入为最接近的整数。" ID="ID_386028583" CREATED="1691076508953" MODIFIED="1691076510474"/>
</node>
<node TEXT="sqrt(x)" ID="ID_1497022596" CREATED="1691076530821" MODIFIED="1691076532865">
<node TEXT="返回数的平方根。" ID="ID_433938386" CREATED="1691076536031" MODIFIED="1691076542940"/>
</node>
</node>
<node TEXT="Date对象" FOLDED="true" POSITION="bottom_or_right" ID="ID_1580263011" CREATED="1687770669580" MODIFIED="1687770675050">
<node TEXT="继承自Object" FOLDED="true" ID="ID_847292853" CREATED="1691074125681" MODIFIED="1691074870954">
<node TEXT="constructor" POSITION="bottom_or_right" ID="ID_1823136592" CREATED="1690826471722" MODIFIED="1690826471722"/>
<node TEXT="toLocaleString" POSITION="bottom_or_right" ID="ID_1430370497" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="toString" POSITION="bottom_or_right" ID="ID_1506347075" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="valueOf" POSITION="bottom_or_right" ID="ID_1608347664" CREATED="1690826471724" MODIFIED="1690826471724"/>
</node>
<node TEXT="获取时间" FOLDED="true" ID="ID_1094023369" CREATED="1691075723938" MODIFIED="1691115331809">
<node TEXT="getDate()" ID="ID_779486601" CREATED="1691075340557" MODIFIED="1691075349514">
<node TEXT="从 Date 对象返回一个月中的某一天 (1 ~ 31)。" ID="ID_626421608" CREATED="1691075350116" MODIFIED="1691075351471"/>
</node>
<node TEXT="getDay()" ID="ID_855631573" CREATED="1691075356829" MODIFIED="1691075358553">
<node TEXT="从 Date 对象返回一周中的某一天 (0 ~ 6)。 0表示周日" ID="ID_1795485870" CREATED="1691075362588" MODIFIED="1691115551691"/>
</node>
<node TEXT="getFullYear()" ID="ID_912497140" CREATED="1691075367960" MODIFIED="1691075372634">
<node TEXT="从 Date 对象以四位数字返回年份。" ID="ID_789715963" CREATED="1691075372636" MODIFIED="1691075373884"/>
</node>
<node TEXT="getHours()" ID="ID_1092448358" CREATED="1691075377965" MODIFIED="1691075379400">
<node TEXT="返回 Date 对象的小时 (0 ~ 23)。" ID="ID_1682499369" CREATED="1691075382910" MODIFIED="1691075384531"/>
</node>
<node TEXT="getMilliseconds()" ID="ID_143574847" CREATED="1691075389468" MODIFIED="1691075390806">
<node TEXT="返回 Date 对象的毫秒(0 ~ 999)。" ID="ID_1324472060" CREATED="1691075394546" MODIFIED="1691075395639"/>
</node>
<node TEXT="getMinutes()" ID="ID_1582370397" CREATED="1691075399635" MODIFIED="1691075401130">
<node TEXT="返回 Date 对象的分钟 (0 ~ 59)。" ID="ID_361472249" CREATED="1691075404706" MODIFIED="1691075405826"/>
</node>
<node TEXT="getMonth()" ID="ID_1141917973" CREATED="1691075410281" MODIFIED="1691075411685">
<node TEXT="从 Date 对象返回月份 (0 ~ 11)。" ID="ID_1661005253" CREATED="1691075414916" MODIFIED="1691075416063"/>
</node>
<node TEXT="getSeconds()" ID="ID_622345180" CREATED="1691075420916" MODIFIED="1691075422333">
<node TEXT="返回 Date 对象的秒数 (0 ~ 59)。" ID="ID_1904427176" CREATED="1691075426036" MODIFIED="1691075427199"/>
</node>
<node TEXT="getTime()" ID="ID_328823429" CREATED="1691075432907" MODIFIED="1691075434244">
<node TEXT="返回 1970 年 1 月 1 日至今的毫秒数。" ID="ID_1347455397" CREATED="1691075437984" MODIFIED="1691075439380"/>
</node>
<node TEXT="getTimezoneOffset()" ID="ID_355729406" CREATED="1691075444186" MODIFIED="1691075445719">
<node TEXT="返回本地时间与格林威治标准时间 (GMT) 的分钟差。" ID="ID_1467326304" CREATED="1691075449095" MODIFIED="1691075450183"/>
</node>
<node TEXT="getUTCDate()" ID="ID_1405640928" CREATED="1691075454859" MODIFIED="1691075456542">
<node TEXT="根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。" ID="ID_1889270640" CREATED="1691075460029" MODIFIED="1691075463919"/>
</node>
<node TEXT="getUTCDay()" ID="ID_1076392932" CREATED="1691075474941" MODIFIED="1691075476486">
<node TEXT="根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。" ID="ID_1033269774" CREATED="1691075477231" MODIFIED="1691075485940"/>
</node>
<node TEXT="getUTCFullYear()" ID="ID_403416447" CREATED="1691075489935" MODIFIED="1691075491576">
<node TEXT="根据世界时从 Date 对象返回四位数的年份" ID="ID_480067625" CREATED="1691075494742" MODIFIED="1691075495940"/>
</node>
<node TEXT="getUTCHours()" ID="ID_1417802367" CREATED="1691075502829" MODIFIED="1691075504668">
<node TEXT="根据世界时返回 Date 对象的小时 (0 ~ 23)。" ID="ID_1560579962" CREATED="1691075508289" MODIFIED="1691075509660"/>
</node>
<node TEXT="getUTCMilliseconds()" ID="ID_249636130" CREATED="1691075514354" MODIFIED="1691075516597">
<node TEXT="根据世界时返回 Date 对象的毫秒(0 ~ 999)。" ID="ID_1047498945" CREATED="1691075520203" MODIFIED="1691075521475"/>
</node>
<node TEXT="getUTCMinutes()" ID="ID_1855363789" CREATED="1691075525953" MODIFIED="1691075527455">
<node TEXT="根据世界时返回 Date 对象的分钟 (0 ~ 59)。" ID="ID_1425760952" CREATED="1691075530754" MODIFIED="1691075531974"/>
</node>
<node TEXT="getUTCMonth()" ID="ID_566381708" CREATED="1691075535909" MODIFIED="1691075537534">
<node TEXT="根据世界时从 Date 对象返回月份 (0 ~ 11)。" ID="ID_212944386" CREATED="1691075541054" MODIFIED="1691075542281"/>
</node>
<node TEXT="getUTCSeconds()" ID="ID_1669680574" CREATED="1691075545812" MODIFIED="1691075547328">
<node TEXT="根据世界时返回 Date 对象的秒钟 (0 ~ 59)。" ID="ID_586882145" CREATED="1691075551391" MODIFIED="1691075552524"/>
</node>
</node>
<node TEXT="设置时间" FOLDED="true" ID="ID_1747378207" CREATED="1691075992311" MODIFIED="1691075997817">
<node TEXT="setDate()" ID="ID_728668598" CREATED="1691075584631" MODIFIED="1691075589209">
<node TEXT="设置 Date 对象中月的某一天 (1 ~ 31)。" ID="ID_1162189728" CREATED="1691075593337" MODIFIED="1691075594533"/>
</node>
<node TEXT="setFullYear()" ID="ID_894090503" CREATED="1691075599916" MODIFIED="1691075601440">
<node TEXT="设置 Date 对象中的年份（四位数字）。" ID="ID_1207943196" CREATED="1691075605701" MODIFIED="1691075607989"/>
</node>
<node TEXT="setHours()" ID="ID_1708865679" CREATED="1691075612435" MODIFIED="1691075614522">
<node TEXT="设置 Date 对象中的小时 (0 ~ 23)。" ID="ID_958980521" CREATED="1691075619886" MODIFIED="1691075621160"/>
</node>
<node TEXT="setMilliseconds()" ID="ID_460360338" CREATED="1691075627195" MODIFIED="1691075629483">
<node TEXT="设置 Date 对象中的毫秒 (0 ~ 999)。" ID="ID_1627574209" CREATED="1691075632538" MODIFIED="1691075633686"/>
</node>
<node TEXT="setMinutes()" ID="ID_965549273" CREATED="1691075638456" MODIFIED="1691075642001">
<node TEXT="设置 Date 对象中的分钟 (0 ~ 59)。" ID="ID_230884058" CREATED="1691075645207" MODIFIED="1691075646505"/>
</node>
<node TEXT="setMonth()" ID="ID_713872353" CREATED="1691075651946" MODIFIED="1691075654032">
<node TEXT="设置 Date 对象中月份 (0 ~ 11)。" ID="ID_1421271640" CREATED="1691075657489" MODIFIED="1691075658856"/>
</node>
<node TEXT="setSeconds()" ID="ID_983880001" CREATED="1691075663720" MODIFIED="1691075665992">
<node TEXT="设置 Date 对象中的秒钟 (0 ~ 59)。" ID="ID_1609944940" CREATED="1691075670530" MODIFIED="1691075671977"/>
</node>
<node TEXT="setTime()" ID="ID_79687751" CREATED="1691075677741" MODIFIED="1691075679713">
<node TEXT="setTime() 方法以毫秒设置 Date 对象。" ID="ID_1222275184" CREATED="1691075683059" MODIFIED="1691075684304"/>
</node>
<node TEXT="setUTCDate()" ID="ID_73018383" CREATED="1691075691859" MODIFIED="1691075693920">
<node TEXT="根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。" ID="ID_1999244757" CREATED="1691075697544" MODIFIED="1691075698647"/>
</node>
<node TEXT="setUTCFullYear()" ID="ID_1052267361" CREATED="1691075705192" MODIFIED="1691075707751">
<node TEXT="根据世界时设置 Date 对象中的年份（四位数字）" ID="ID_1950429307" CREATED="1691075711626" MODIFIED="1691075713817"/>
</node>
<node TEXT="setUTCHours()" ID="ID_1836224087" CREATED="1691075743928" MODIFIED="1691075745501">
<node TEXT="根据世界时设置 Date 对象中的小时 (0 ~ 23)。" ID="ID_1663457781" CREATED="1691075753125" MODIFIED="1691075754579"/>
</node>
<node TEXT="setUTCMilliseconds()" ID="ID_1337365148" CREATED="1691075758832" MODIFIED="1691075763011">
<node TEXT="根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。" ID="ID_1665388920" CREATED="1691075765994" MODIFIED="1691075767425"/>
</node>
<node TEXT="setUTCMinutes()" ID="ID_1445446908" CREATED="1691075772006" MODIFIED="1691075773565">
<node TEXT="根据世界时设置 Date 对象中的分钟 (0 ~ 59)。" ID="ID_145301742" CREATED="1691075776762" MODIFIED="1691075778672"/>
</node>
<node TEXT="setUTCMonth()" ID="ID_1784112007" CREATED="1691075792828" MODIFIED="1691075794601">
<node TEXT="根据世界时设置 Date 对象中的月份 (0 ~ 11)。" ID="ID_678837172" CREATED="1691075798727" MODIFIED="1691075799943"/>
</node>
<node TEXT="setUTCSeconds()" ID="ID_276077098" CREATED="1691075804131" MODIFIED="1691075805786">
<node TEXT="setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。" ID="ID_253198609" CREATED="1691075810518" MODIFIED="1691075811996"/>
</node>
</node>
<node TEXT="parse()" FOLDED="true" ID="ID_1275362274" CREATED="1691075568195" MODIFIED="1691075570192">
<node TEXT="返回1970年1月1日午夜到指定日期（字符串）的毫秒数。" ID="ID_1592395221" CREATED="1691075579160" MODIFIED="1691075580350"/>
</node>
<node TEXT="格式化输出" FOLDED="true" ID="ID_1498574642" CREATED="1691076031818" MODIFIED="1691076038543">
<node TEXT="toDateString()" ID="ID_1257269629" CREATED="1691075824696" MODIFIED="1691075826265">
<node TEXT="把 Date 对象的日期部分转换为字符串。" ID="ID_1465649835" CREATED="1691075829984" MODIFIED="1691075831166"/>
</node>
<node TEXT="toTimeString()" ID="ID_1642236758" CREATED="1691075943225" MODIFIED="1691075944879">
<node TEXT="把 Date 对象的时间部分转换为字符串。" ID="ID_1821056365" CREATED="1691075948363" MODIFIED="1691075949983"/>
</node>
<node TEXT="toLocaleDateString()" ID="ID_500211599" CREATED="1691075871723" MODIFIED="1691075873502">
<node TEXT="根据本地时间格式，把 Date 对象的日期部分转换为字符串。" ID="ID_610436146" CREATED="1691075895896" MODIFIED="1691075897247"/>
</node>
<node TEXT="toLocaleTimeString()" ID="ID_1504461182" CREATED="1691075901903" MODIFIED="1691075903586">
<node TEXT="根据本地时间格式，把 Date 对象的时间部分转换为字符串。" ID="ID_1951982362" CREATED="1691075906814" MODIFIED="1691075908201"/>
</node>
<node TEXT="toJSON()" ID="ID_346665589" CREATED="1691075855778" MODIFIED="1691075857496">
<node TEXT="以 JSON 数据格式返回日期字符串。" ID="ID_1871439313" CREATED="1691075861088" MODIFIED="1691075862578"/>
</node>
<node TEXT="toISOString()" ID="ID_952531666" CREATED="1691075840560" MODIFIED="1691075847541">
<node TEXT="使用 ISO 标准返回字符串的日期格式。" ID="ID_832895171" CREATED="1691075847544" MODIFIED="1691075848905"/>
</node>
<node TEXT="toUTCString()" ID="ID_223211188" CREATED="1691075954778" MODIFIED="1691075956660">
<node TEXT="根据世界时，把 Date 对象转换为字符串。" ID="ID_1045379183" CREATED="1691075960660" MODIFIED="1691075962175"/>
</node>
<node TEXT="toLocaleString()" ID="ID_1010995365" CREATED="1691075912195" MODIFIED="1691075917707">
<node TEXT="据本地时间格式，把 Date 对象转换为字符串。" ID="ID_1644587948" CREATED="1691075917712" MODIFIED="1691075919120"/>
</node>
<node TEXT="toString()" ID="ID_1337846849" CREATED="1691075933085" MODIFIED="1691075934764">
<node TEXT="把 Date 对象转换为字符串。" ID="ID_1715126917" CREATED="1691075937964" MODIFIED="1691075939197"/>
</node>
</node>
</node>
<node TEXT="RegExp对象" FOLDED="true" POSITION="bottom_or_right" ID="ID_1406273886" CREATED="1687770670202" MODIFIED="1687770691210">
<node TEXT="compile()" FOLDED="true" ID="ID_750198291" CREATED="1690827052516" MODIFIED="1691018491065">
<node TEXT="重新编译正则对象" ID="ID_269082675" CREATED="1691018385326" MODIFIED="1691018394125"/>
</node>
<node TEXT="dotAll" FOLDED="true" ID="ID_1882254959" CREATED="1690827052517" MODIFIED="1690827052517">
<node TEXT="是否使用s模式" ID="ID_442491938" CREATED="1691019420450" MODIFIED="1691019433513"/>
</node>
<node TEXT="exec()" FOLDED="true" ID="ID_442573350" CREATED="1690827052518" MODIFIED="1691018494890">
<node TEXT="执行一次正则匹配，返回匹配结果" ID="ID_839550785" CREATED="1691018401374" MODIFIED="1691032994146"/>
</node>
<node TEXT="flags" FOLDED="true" ID="ID_352467112" CREATED="1690827052518" MODIFIED="1690827052518">
<node TEXT="获取模式修正符" ID="ID_1448979890" CREATED="1691018953804" MODIFIED="1691018967227"/>
</node>
<node TEXT="global" FOLDED="true" ID="ID_1740017170" CREATED="1690827052518" MODIFIED="1690827052518">
<node TEXT="是否是全局模式" ID="ID_521147509" CREATED="1691018416008" MODIFIED="1691018421645"/>
</node>
<node TEXT="hasIndices" FOLDED="true" ID="ID_192280267" CREATED="1690827052518" MODIFIED="1690827052518">
<node TEXT="是否使用了d模式" ID="ID_526559996" CREATED="1691019534353" MODIFIED="1691019544610"/>
</node>
<node TEXT="ignoreCase" FOLDED="true" ID="ID_651042861" CREATED="1690827052518" MODIFIED="1690827052518">
<node TEXT="是否是忽略大小写模式" ID="ID_854060857" CREATED="1691018424978" MODIFIED="1691018432368"/>
</node>
<node TEXT="multiline" FOLDED="true" ID="ID_822819846" CREATED="1690827052519" MODIFIED="1690827052519">
<node TEXT="是否是多行模式" ID="ID_1949804978" CREATED="1691018433740" MODIFIED="1691018438924"/>
</node>
<node TEXT="source: &quot;(?:)&quot;" FOLDED="true" ID="ID_645535136" CREATED="1690827052519" MODIFIED="1690827052519">
<node TEXT="匹配的字符串" ID="ID_198382905" CREATED="1691018504785" MODIFIED="1691018515625"/>
</node>
<node TEXT="test()" FOLDED="true" ID="ID_562673758" CREATED="1690827052519" MODIFIED="1691018481974">
<node TEXT="正则测试，返回布尔值" ID="ID_1272098174" CREATED="1691018442371" MODIFIED="1691018450477"/>
</node>
<node TEXT="toString()" FOLDED="true" ID="ID_1330290649" CREATED="1690827052519" MODIFIED="1691018473575">
<node TEXT="字符串输出" ID="ID_1149786693" CREATED="1691018451664" MODIFIED="1691018470959"/>
</node>
<node TEXT="unicode" ID="ID_1360469846" CREATED="1690827052519" MODIFIED="1690827052519"/>
<node TEXT="unicodeSets" ID="ID_1816545663" CREATED="1690827052519" MODIFIED="1690827052519"/>
<node TEXT="继承自Object" FOLDED="true" ID="ID_1577319263" CREATED="1691074125681" MODIFIED="1691074870954">
<node TEXT="constructor" POSITION="bottom_or_right" ID="ID_1770816480" CREATED="1690826471722" MODIFIED="1690826471722"/>
<node TEXT="toLocaleString" POSITION="bottom_or_right" ID="ID_352596579" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="toString" POSITION="bottom_or_right" ID="ID_1801926953" CREATED="1690826471724" MODIFIED="1690826471724"/>
<node TEXT="valueOf" POSITION="bottom_or_right" ID="ID_1125341761" CREATED="1690826471724" MODIFIED="1690826471724"/>
</node>
</node>
</node>
<node TEXT="集合引用类型" ID="ID_1160254289" CREATED="1687770647826" MODIFIED="1687770664859">
<node TEXT="Object对象" FOLDED="true" ID="ID_1990043730" CREATED="1687770744025" MODIFIED="1687770747546">
<node TEXT="constructor" ID="ID_820137635" CREATED="1690827118761" MODIFIED="1690827118761">
<node TEXT="获取原型的构造方法" ID="ID_1387292050" CREATED="1691074966336" MODIFIED="1691074975454"/>
</node>
<node TEXT="hasOwnProperty()" ID="ID_378471249" CREATED="1690827118761" MODIFIED="1691075029037">
<node TEXT="是用来检测属性是否为对象的自有属性,只会检查对象的自有属性，对象原形上的属性其不会检测；" ID="ID_1382337464" CREATED="1691080776764" MODIFIED="1691080830606"/>
</node>
<node TEXT="isPrototypeOf()" ID="ID_1319769824" CREATED="1690827118762" MODIFIED="1691075021232">
<node TEXT="用于指示对象是否存在于另一个对象的原型链中，存在返回true，否则返回false" ID="ID_1604758264" CREATED="1691080855342" MODIFIED="1691080856619"/>
</node>
<node TEXT="propertyIsEnumerable()" ID="ID_1645192770" CREATED="1690827118762" MODIFIED="1691075025173">
<node TEXT="用来判断改对象属性是否可以用for...in枚举（遍历）" ID="ID_837454412" CREATED="1691080918694" MODIFIED="1691080920085"/>
</node>
<node TEXT="toLocaleString()" ID="ID_877523746" CREATED="1690827118762" MODIFIED="1691075017650" VGAP_QUANTITY="3 pt">
<node TEXT="输出本地字符串格式" ID="ID_674401278" CREATED="1691074995679" MODIFIED="1691075000816"/>
</node>
<node TEXT="toString()" ID="ID_841535401" CREATED="1690827118762" MODIFIED="1691075014609">
<node TEXT="输出字符串格式" ID="ID_1056296784" CREATED="1691074989784" MODIFIED="1691074994834"/>
</node>
<node TEXT="valueOf()" ID="ID_74286648" CREATED="1690827118762" MODIFIED="1691075009109">
<node TEXT="获取对象原始值" ID="ID_1475909297" CREATED="1691074982007" MODIFIED="1691074988703"/>
</node>
<node TEXT="getOwnPropertyDescriptor()" ID="ID_1103852327" CREATED="1691080902514" MODIFIED="1691080904288">
<node TEXT="获取属性描述符" ID="ID_1894198721" CREATED="1691080925099" MODIFIED="1691080933383"/>
</node>
<node TEXT="defineProperty()" ID="ID_391429995" CREATED="1691080910371" MODIFIED="1691080911685">
<node TEXT="设置属性描述符" ID="ID_1585925429" CREATED="1691080934452" MODIFIED="1691080938479"/>
</node>
</node>
<node TEXT="Array对象" FOLDED="true" ID="ID_1364024143" CREATED="1687770752548" MODIFIED="1687770756624">
<node TEXT="复制填充" FOLDED="true" ID="ID_616053746" CREATED="1691077741475" MODIFIED="1691077745985">
<node TEXT="fill()" ID="ID_1846959549" CREATED="1690827240169" MODIFIED="1691077307739">
<node TEXT="使用一个固定值来填充数组。" ID="ID_1511155244" CREATED="1691077303826" MODIFIED="1691077305864"/>
</node>
<node TEXT="copyWithin(pos, start, end)" ID="ID_1670499443" CREATED="1690827240168" MODIFIED="1691168178799">
<node TEXT="从数组的指定位置拷贝元素到数组的另一个指定位置中。" ID="ID_1439470622" CREATED="1691077268397" MODIFIED="1691077270373"/>
</node>
</node>
<node TEXT="添加删除元素(操作原数组)" FOLDED="true" ID="ID_524087249" CREATED="1691077770775" MODIFIED="1691218254864">
<node TEXT="pop()" ID="ID_283966054" CREATED="1690827240171" MODIFIED="1691077429261">
<node TEXT="删除数组的最后一个元素并返回删除的元素。" ID="ID_498636591" CREATED="1691077429265" MODIFIED="1691077430735"/>
</node>
<node TEXT="push()" ID="ID_646724666" CREATED="1690827240171" MODIFIED="1691077439818">
<node TEXT="&#x9;向数组的末尾添加一个或更多元素，并返回新的长度。" ID="ID_1318684568" CREATED="1691077439822" MODIFIED="1691077441546"/>
</node>
<node TEXT="unshift()" ID="ID_1101200151" CREATED="1690827240174" MODIFIED="1691077539596">
<node TEXT="向数组的开头添加一个或更多元素，并返回新的长度。" ID="ID_1511233495" CREATED="1691077539601" MODIFIED="1691077540997"/>
</node>
<node TEXT="shift()" ID="ID_1368995387" CREATED="1690827240172" MODIFIED="1691077478856">
<node TEXT="删除数组的第一个元素" ID="ID_1318243291" CREATED="1691077476466" MODIFIED="1691077488802"/>
</node>
</node>
<node TEXT="数组迭代器方法" FOLDED="true" ID="ID_1566931410" CREATED="1691077705784" MODIFIED="1691077735325">
<node TEXT="entries()" ID="ID_1217955091" CREATED="1690827240169" MODIFIED="1691077281802">
<node TEXT="返回数组的可迭代对象" ID="ID_201953812" CREATED="1691077278140" MODIFIED="1691077279890"/>
</node>
<node TEXT="keys()" ID="ID_817524168" CREATED="1690827240171" MODIFIED="1691077587669">
<node TEXT="返回数组索引的迭代器" ID="ID_359986901" CREATED="1691077587674" MODIFIED="1691077589102"/>
</node>
<node TEXT="values()" ID="ID_842586806" CREATED="1690827240174" MODIFIED="1691077599937">
<node TEXT="返回数组元素的迭代器" ID="ID_1739682294" CREATED="1691077599941" MODIFIED="1691077601754"/>
</node>
</node>
<node TEXT="数组操作" FOLDED="true" ID="ID_1249252393" CREATED="1691077969428" MODIFIED="1691077973347">
<node TEXT="concat()" ID="ID_58544334" CREATED="1690827240166" MODIFIED="1691077247996">
<node TEXT="连接两个或更多的数组，并返回结果。" ID="ID_1787322903" CREATED="1691077236736" MODIFIED="1691077238689"/>
</node>
<node TEXT="splice()" ID="ID_228261711" CREATED="1690827240173" MODIFIED="1691077517015">
<node TEXT="从数组中添加或删除元素。" ID="ID_1717632729" CREATED="1691077517020" MODIFIED="1691077518634"/>
</node>
<node TEXT="slice()" ID="ID_898377116" CREATED="1690827240173" MODIFIED="1691077490965">
<node TEXT="选取数组的的一部分，并返回一个新数组。" ID="ID_1928748070" CREATED="1691077490969" MODIFIED="1691077492454"/>
</node>
<node TEXT="join()" POSITION="bottom_or_right" ID="ID_1646962371" CREATED="1690827240171" MODIFIED="1691077387175">
<node TEXT="把数组的所有元素放入一个字符串。" ID="ID_1639004615" CREATED="1691077387179" MODIFIED="1691077388687"/>
</node>
</node>
<node TEXT="搜索和位置方法" FOLDED="true" ID="ID_1236827723" CREATED="1691078024776" MODIFIED="1691078027538">
<node TEXT="find()" ID="ID_1636206126" CREATED="1690827240169" MODIFIED="1691077323648">
<node TEXT="返回符合传入测试（函数）条件的数组元素。" ID="ID_688008837" CREATED="1691077319864" MODIFIED="1691077321603"/>
</node>
<node TEXT="findIndex()" ID="ID_1902552351" CREATED="1690827240169" MODIFIED="1691077330582">
<node TEXT="返回符合传入测试（函数）条件的数组元素索引。" ID="ID_444443716" CREATED="1691077330586" MODIFIED="1691077332040"/>
</node>
<node TEXT="findLast()" ID="ID_1997529198" CREATED="1690827240170" MODIFIED="1691222985429">
<node TEXT="返回符合传入测试（函数）条件的数组元素。（倒数）" ID="ID_442366826" CREATED="1691220172469" MODIFIED="1691220185354"/>
</node>
<node TEXT="findLastIndex()" ID="ID_321201421" CREATED="1690827240170" MODIFIED="1691222982607">
<node TEXT="返回符合传入测试（函数）条件的数组元素索引。（倒数）" ID="ID_347306391" CREATED="1691220190358" MODIFIED="1691220194805"/>
</node>
<node TEXT="includes（）" POSITION="bottom_or_right" ID="ID_1910429963" CREATED="1690827240170" MODIFIED="1691222979748">
<node TEXT="查找是否具有指定的值" ID="ID_38230019" CREATED="1691222973032" MODIFIED="1691222974633"/>
</node>
<node TEXT="indexOf()" POSITION="bottom_or_right" ID="ID_924805523" CREATED="1690827240170" MODIFIED="1691077376469">
<node TEXT="搜索数组中的元素，并返回它所在的位置。" ID="ID_1399534492" CREATED="1691077370559" MODIFIED="1691077371901"/>
</node>
<node TEXT="lastIndexOf()" POSITION="bottom_or_right" ID="ID_51193732" CREATED="1690827240171" MODIFIED="1691077403015">
<node TEXT="返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。" ID="ID_513369160" CREATED="1691077403020" MODIFIED="1691077408966"/>
</node>
<node TEXT="at()" POSITION="bottom_or_right" ID="ID_917752776" CREATED="1691080398682" MODIFIED="1691080403869">
<node TEXT="用于接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数" ID="ID_723054390" CREATED="1691080411454" MODIFIED="1691080413244"/>
</node>
</node>
<node TEXT="归并方法" FOLDED="true" ID="ID_803537861" CREATED="1691078167903" MODIFIED="1691078169938">
<node TEXT="reduce" ID="ID_1683093094" CREATED="1690827240171" MODIFIED="1690827240171">
<node TEXT="迭代数组的所有项，并在此基础上构建一个最终返回值，从数组第一项开始遍历到最后一项" ID="ID_1632456109" CREATED="1691078185209" MODIFIED="1691078202805"/>
</node>
<node TEXT="reduceRight" ID="ID_27226038" CREATED="1690827240172" MODIFIED="1690827240172">
<node TEXT="迭代数组的所有项，并在此基础上构建一个最终返回值，从最后一项开始遍历至第一项" ID="ID_1863611731" CREATED="1691078209686" MODIFIED="1691078217352"/>
</node>
</node>
<node TEXT="排序方法" FOLDED="true" ID="ID_1127214935" CREATED="1691077883896" MODIFIED="1691077888561">
<node TEXT="sort()" ID="ID_1003992506" CREATED="1690827240173" MODIFIED="1691077508167">
<node TEXT="对数组的元素进行排序。" ID="ID_1870235874" CREATED="1691077508172" MODIFIED="1691077509512"/>
</node>
<node TEXT="reverse()" ID="ID_986300271" CREATED="1690827240172" MODIFIED="1691077459852">
<node TEXT="反转数组的元素顺序。" ID="ID_1066313049" CREATED="1691077455276" MODIFIED="1691077464296"/>
</node>
</node>
<node TEXT="迭代方法" ID="ID_1150063897" CREATED="1691078143259" MODIFIED="1691078146108">
<node TEXT="forEach()" ID="ID_1643536366" CREATED="1690827240170" MODIFIED="1691077343782">
<node TEXT="数组每个元素都执行一次回调函数。" ID="ID_1507481405" CREATED="1691077343786" MODIFIED="1691077345291"/>
</node>
<node TEXT="map()" ID="ID_52696970" CREATED="1690827240171" MODIFIED="1691077422840">
<node TEXT="通过指定函数处理数组的每个元素，并返回处理后的数组。" ID="ID_1740432253" CREATED="1691077418780" MODIFIED="1691077420685"/>
</node>
<node TEXT="every()" ID="ID_244519879" CREATED="1690827240169" MODIFIED="1691077293326">
<node TEXT="检测数组元素的每个元素是否都符合条件。返回布尔值" ID="ID_1689653625" CREATED="1691077287969" MODIFIED="1691167624890"/>
</node>
<node TEXT="some()" ID="ID_1062972349" CREATED="1690827240173" MODIFIED="1691077499861">
<node TEXT="检测数组元素中是否有元素符合指定条件。返回布尔值" ID="ID_211521610" CREATED="1691077499866" MODIFIED="1691167648273"/>
</node>
<node TEXT="filter()" ID="ID_846245565" CREATED="1690827240169" MODIFIED="1691077313302">
<node TEXT="检测数组元素，并返回符合条件所有元素的数组。" ID="ID_380077634" CREATED="1691077313307" MODIFIED="1691077314941"/>
</node>
</node>
<node TEXT="数组扁平化" FOLDED="true" ID="ID_1264642795" CREATED="1691167744047" MODIFIED="1691167748423">
<node TEXT="flat()" ID="ID_125381269" CREATED="1690827240170" MODIFIED="1691080617191">
<node TEXT="创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。（多维数组扁平化）" ID="ID_801905899" CREATED="1691080613172" MODIFIED="1691167420511"/>
</node>
<node TEXT="flatMap()" ID="ID_1898235177" CREATED="1690827240170" MODIFIED="1691080371157">
<node TEXT="使用映射函数映射每个元素，然后将结果压缩成一个新数组， flatMap 通常在合并成一种方法的效率稍微高一些" ID="ID_817806348" CREATED="1691080366105" MODIFIED="1691167482921"/>
</node>
</node>
</node>
<node TEXT="定形数组" FOLDED="true" ID="ID_1278444287" CREATED="1687770778363" MODIFIED="1687770787282">
<node TEXT="主要是为了配合2D/3D绘画设置的数据类型，可以预先分配内存" ID="ID_402302328" CREATED="1691165874627" MODIFIED="1691166361432"/>
<node TEXT="ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。" ID="ID_294676115" CREATED="1691165938616" MODIFIED="1691165957571"/>
</node>
<node TEXT="Map对象/映射" FOLDED="true" ID="ID_134580590" CREATED="1687770793188" MODIFIED="1691164084051">
<node TEXT="常用函数" ID="ID_1948099533" CREATED="1691163297414" MODIFIED="1691199177783">
<node TEXT="clear()" ID="ID_480012280" CREATED="1690827373906" MODIFIED="1691163416355">
<node TEXT="清除整个映射" ID="ID_1424505303" CREATED="1691163416360" MODIFIED="1691163440835"/>
</node>
<node TEXT="delete()" ID="ID_1486907302" CREATED="1690827373913" MODIFIED="1691163404149">
<node TEXT="删除指定key的映射" ID="ID_1336670558" CREATED="1691163404153" MODIFIED="1691163451333"/>
</node>
<node TEXT="forEach（）" ID="ID_1315407397" CREATED="1690827373913" MODIFIED="1691163812942">
<node TEXT="对每个键值对执行函数操作" ID="ID_1891808476" CREATED="1691163565974" MODIFIED="1691163827679"/>
</node>
<node TEXT="get()" ID="ID_585801232" CREATED="1690827373914" MODIFIED="1691163484198">
<node TEXT="获取映射指定名称的值" ID="ID_1785669429" CREATED="1691163478031" MODIFIED="1691163494892"/>
</node>
<node TEXT="has()" ID="ID_1217757093" CREATED="1690827373914" MODIFIED="1691163474522">
<node TEXT="检测映射是否具有制定值" ID="ID_961123136" CREATED="1691163456687" MODIFIED="1691163467636"/>
</node>
<node TEXT="set()" ID="ID_1231892285" CREATED="1690827373914" MODIFIED="1691163547475">
<node TEXT="向映射中添加键值对" ID="ID_1135914268" CREATED="1691163536809" MODIFIED="1691163559463"/>
</node>
<node TEXT="size" ID="ID_359847636" CREATED="1690827373914" MODIFIED="1690827373914">
<node TEXT="获取映射长度" ID="ID_222819138" CREATED="1691163504695" MODIFIED="1691163509851"/>
</node>
<node TEXT="values（）" ID="ID_1232204822" CREATED="1690827373914" MODIFIED="1691163682911">
<node TEXT="获取值的迭代器" ID="ID_184686146" CREATED="1691163682916" MODIFIED="1691163686827"/>
</node>
<node TEXT="entries（）" FOLDED="true" POSITION="bottom_or_right" ID="ID_1902060443" CREATED="1690827373913" MODIFIED="1691163680287">
<node TEXT="获取键值迭代器" ID="ID_1804134969" CREATED="1691163666489" MODIFIED="1691163677520"/>
</node>
<node TEXT="keys（）" POSITION="bottom_or_right" ID="ID_1341271294" CREATED="1690827373914" MODIFIED="1691163701688">
<node TEXT="获取键的迭代器" ID="ID_1427866419" CREATED="1691163687810" MODIFIED="1691163697770"/>
</node>
</node>
<node TEXT="基本操作" ID="ID_168028474" CREATED="1691163289327" MODIFIED="1691163305365">
<node TEXT="实例集合" ID="ID_1547551700" CREATED="1691163305926" MODIFIED="1691163312441">
<node TEXT="const myMap = new Map([[key,value],[key,value]...])" ID="ID_321426880" CREATED="1691163312447" MODIFIED="1691163361253"/>
</node>
</node>
<node TEXT="与Object差异" FOLDED="true" ID="ID_1925181071" CREATED="1691163765856" MODIFIED="1691163771544">
<node TEXT="1。Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作&#xa;2。对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大&#xa;3。对于&#xd;&#xa;在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别" ID="ID_234202432" CREATED="1691163771549" MODIFIED="1691163868370"/>
</node>
</node>
<node TEXT="WeakMap对象/弱映射" FOLDED="true" ID="ID_674418584" CREATED="1687770811819" MODIFIED="1691164089651">
<node TEXT="常用方法" ID="ID_1453148897" CREATED="1691164150630" MODIFIED="1691164157258">
<node TEXT="delete（）" ID="ID_70502882" CREATED="1690827427756" MODIFIED="1691164161503">
<node TEXT="删除指定键的映射" ID="ID_1326729472" CREATED="1691164646116" MODIFIED="1691164656594"/>
</node>
<node TEXT="get（）" ID="ID_1419792001" CREATED="1690827427757" MODIFIED="1691164163921">
<node TEXT="获取指定键的映射值" ID="ID_855404204" CREATED="1691164658124" MODIFIED="1691164665476"/>
</node>
<node TEXT="has（）" ID="ID_789577096" CREATED="1690827427758" MODIFIED="1691164167021">
<node TEXT="检查是否具有指定键的映射值" ID="ID_1148093355" CREATED="1691164666485" MODIFIED="1691164680008"/>
</node>
<node TEXT="set（）" ID="ID_67995166" CREATED="1690827427758" MODIFIED="1691164169407">
<node TEXT="添加修改指定键的映射值" ID="ID_1664250130" CREATED="1691164680865" MODIFIED="1691164690169"/>
</node>
</node>
<node TEXT="基本操作" ID="ID_383118318" CREATED="1691164170574" MODIFIED="1691164175272">
<node TEXT="const wm = new WeakMap();" ID="ID_1441488359" CREATED="1691164622988" MODIFIED="1691164639047"/>
</node>
<node TEXT="使用场景" ID="ID_846130597" CREATED="1691164186572" MODIFIED="1691164190889">
<node TEXT="成员私有化" ID="ID_391229481" CREATED="1691164485970" MODIFIED="1691164493476"/>
<node TEXT="DOM节点操作" ID="ID_1873220757" CREATED="1691164541434" MODIFIED="1691164550252">
<node TEXT="const wm = new WeakMap();&#xa;const loginButton = document.querySelecto(&apos;#login&apos;);&#xa;// 给这个节点关联一些元数据&#xa;wm.set(loginButton, {disabled: true});" ID="ID_1171219561" CREATED="1691164550257" MODIFIED="1691164565614"/>
</node>
</node>
<node TEXT="弱映射与映射的区别在于，弱映射不会影响系统的回收机制，如果引用被删除，则系统回收不会被弱映射阻止" ID="ID_1396873245" CREATED="1691164577255" MODIFIED="1691164614415"/>
</node>
<node TEXT="Set对象" FOLDED="true" ID="ID_353129503" CREATED="1687770836079" MODIFIED="1687770840924">
<node TEXT="常用函数" FOLDED="true" ID="ID_600973562" CREATED="1691164720096" MODIFIED="1691164727665">
<node TEXT="add（值）" ID="ID_1213197184" CREATED="1690827478588" MODIFIED="1691164801014">
<node TEXT="添加数据到集合中" ID="ID_587548319" CREATED="1691164759909" MODIFIED="1691164767386"/>
</node>
<node TEXT="clear（）" ID="ID_1568650103" CREATED="1690827478588" MODIFIED="1691164770183">
<node TEXT="清空集合" ID="ID_460389268" CREATED="1691164770188" MODIFIED="1691164778039"/>
</node>
<node TEXT="delete（值）" ID="ID_408880959" CREATED="1690827478590" MODIFIED="1691164805759">
<node TEXT="删除集合中的指定值" ID="ID_127429489" CREATED="1691164805764" MODIFIED="1691164811418"/>
</node>
<node TEXT="entries（）" ID="ID_1400846390" CREATED="1690827478590" MODIFIED="1691164821427">
<node TEXT="获取集合的迭代器" ID="ID_46251165" CREATED="1691164812716" MODIFIED="1691164890082"/>
</node>
<node TEXT="forEach（）" ID="ID_423162342" CREATED="1690827478590" MODIFIED="1691164825500">
<node TEXT="对集合中每个数据进行函数操作" ID="ID_1907189538" CREATED="1691164825505" MODIFIED="1691164834607"/>
</node>
<node TEXT="has（）" ID="ID_1013173595" CREATED="1690827478590" MODIFIED="1691164838258">
<node TEXT="检测是否具有指定的值" ID="ID_1739034332" CREATED="1691164835572" MODIFIED="1691164847536"/>
</node>
<node TEXT="keys（）/values（）" ID="ID_89144498" CREATED="1690827478590" MODIFIED="1691164905255">
<node TEXT="获取迭代器" ID="ID_727506112" CREATED="1691164850609" MODIFIED="1691164884371"/>
</node>
<node TEXT="size" ID="ID_1170282335" CREATED="1690827478590" MODIFIED="1690827478590">
<node TEXT="获取集合的长度" ID="ID_1885664420" CREATED="1691164946830" MODIFIED="1691164951426"/>
</node>
</node>
<node TEXT="基本操作" FOLDED="true" ID="ID_1604304571" CREATED="1691164713677" MODIFIED="1691164731787">
<node TEXT="const m = new Set(可迭代对象);" ID="ID_1401808202" CREATED="1691164732098" MODIFIED="1691164751169"/>
</node>
<node TEXT="扩展功能" ID="ID_9639151" CREATED="1691165104785" MODIFIED="1691165111412">
<node TEXT="求并集" ID="ID_882209989" CREATED="1691165114970" MODIFIED="1691165116136">
<node TEXT="let unionSet = new Set([...setA, ...setB]);" ID="ID_1282829062" CREATED="1691165119878" MODIFIED="1691165121021"/>
</node>
<node TEXT="求交集" ID="ID_1626903907" CREATED="1691165127102" MODIFIED="1691165132215">
<node TEXT="let intersectionSet = new Set([...setA].filter(x =&gt; setB.has(x)));" ID="ID_675064147" CREATED="1691165132602" MODIFIED="1691165133898"/>
</node>
<node TEXT="求差集" ID="ID_946238636" CREATED="1691165142314" MODIFIED="1691165143611">
<node TEXT="let differenceSet = new Set([...setA].filter(x =&gt; !setB.has(x)));" ID="ID_689560835" CREATED="1691165147364" MODIFIED="1691165148643"/>
</node>
</node>
</node>
<node TEXT="WeakSet对象" FOLDED="true" ID="ID_1234695504" CREATED="1687770842234" MODIFIED="1687770851261">
<node TEXT="常用函数" ID="ID_1218238687" CREATED="1691165190384" MODIFIED="1691165193143">
<node TEXT="add（）" ID="ID_184553101" CREATED="1690827516900" MODIFIED="1691165204870">
<node TEXT="向集合中添加数据" ID="ID_514484460" CREATED="1691165204874" MODIFIED="1691165210975"/>
</node>
<node TEXT="delete（）" ID="ID_629625213" CREATED="1690827516901" MODIFIED="1691165216263">
<node TEXT="删除集合中的数据" ID="ID_1020411814" CREATED="1691165213050" MODIFIED="1691165222707"/>
</node>
<node TEXT="has（）" ID="ID_1236395708" CREATED="1690827516901" MODIFIED="1691165229338">
<node TEXT="检测集合中是否存在指定数据" ID="ID_686766109" CREATED="1691165229344" MODIFIED="1691165236077"/>
</node>
</node>
<node TEXT="基本操作" ID="ID_1802946322" CREATED="1691165185200" MODIFIED="1691165196924">
<node TEXT="const ws = new WeakSet();" ID="ID_1382704309" CREATED="1691165197096" MODIFIED="1691165198614"/>
</node>
<node TEXT="注意" ID="ID_808847454" CREATED="1691165271207" MODIFIED="1691165282590">
<node TEXT="弱集合中的值只能是 Object 或者继承自 Object 的类型" ID="ID_117437738" CREATED="1691165282889" MODIFIED="1691165284245"/>
</node>
<node TEXT="使用场景" ID="ID_495544332" CREATED="1691165422115" MODIFIED="1691165434256">
<node TEXT="DOM节点操作" ID="ID_476762816" CREATED="1691165442661" MODIFIED="1691165449962">
<node TEXT="const disabledElements = new WeakSet(); &#xd;&#xa;const loginButton = document.querySelector(&apos;#login&apos;); &#xd;&#xa;// 通过加入对应集合，给这个节点打上“禁用”标签&#xd;&#xa;disabledElements.add(loginButton);" POSITION="bottom_or_right" ID="ID_1129055042" CREATED="1691165434261" MODIFIED="1691165435719"/>
</node>
</node>
</node>
</node>
</node>
<node TEXT="代理与反射" FOLDED="true" POSITION="bottom_or_right" ID="ID_1644140939" CREATED="1687644935483" MODIFIED="1692165495815" VGAP_QUANTITY="3 pt">
<node TEXT="概念" FOLDED="true" ID="ID_729074367" CREATED="1692048673210" MODIFIED="1692048676300">
<node TEXT="代理" POSITION="bottom_or_right" ID="ID_1208564833" CREATED="1692048555923" MODIFIED="1692048560979">
<node TEXT="代理（Proxy）是一种设计模式，它允许我们在访问对象的同时，添加一些额外的操作。代理对象与被代理对象实现相同的接口，代理对象会接受并处理所有对被代理对象的访问请求。&#xa;代理是对象通过一个代理对象来控制对原对象的读取、设置、调用及其他操作，并对这些操作进行预处理或附加操作，主要用于拦截对象" ID="ID_1429544807" CREATED="1692048565548" MODIFIED="1692048606309"/>
</node>
<node TEXT="反射" POSITION="bottom_or_right" ID="ID_976868273" CREATED="1692048607966" MODIFIED="1692048614751">
<node TEXT="反射（Reflection）是指程序可以在运行时获取、操作、修改它本身的状态或行为。反射是一种动态获取类型信息和操作类型的能力，可以在运行时动态调用类中的方法或属性。&#xa;反射可以使我们知晓（获取）对象详情，操控对象的成员（属性），在调用对象的方法时加入额外的逻辑，主要用于操作对象" ID="ID_1261117844" CREATED="1692048622883" MODIFIED="1692048625806"/>
</node>
</node>
<node TEXT="Proxy代理对象" FOLDED="true" ID="ID_834922372" CREATED="1692048697083" MODIFIED="1692048734739">
<node TEXT="实例化对象" ID="ID_578084963" CREATED="1692048752252" MODIFIED="1692048758581">
<node TEXT="let proxy = new Proxy(target,handler)" ID="ID_493189417" CREATED="1692048764803" MODIFIED="1692051998277"/>
<node TEXT="参数" ID="ID_1834449833" CREATED="1692048832434" MODIFIED="1692167195575" VGAP_QUANTITY="3 pt">
<node TEXT="target：被代理的目标对象。" ID="ID_547276017" CREATED="1692048837979" MODIFIED="1692048846650"/>
<node TEXT="handler：定义代理行为的对象。" ID="ID_1887831164" CREATED="1692048851567" MODIFIED="1692167195574">
<node TEXT="get：在读取代理对象的属性时&#xa;set：在对代理对象的属性进行赋值时&#xa;has：在使用 in 运算符检查代理对象是否具有某个属性时&#xa;deleteProperty：在删除代理对象的属性时&#xa;apply：当前代理对象为函数，在调用代理对象时&#xa;construct：在使用 new 运算符创建代理对象的实例时&#xa;getOwnPropertyDescriptor：在获取代理对象的属性描述符时&#xa;defineProperty：在定义代理对象的属性时&#xa;getPrototypeOf：在获取代理对象的原型时&#xa;setPrototypeOf：在设置代理对象的原型时&#xa;isExtensible：在检查代理对象是否可扩展时&#xa;preventExtensions：在防止代理对象的扩展时&#xa;ownKeys：在返回代理对象的所有键时" ID="ID_919730901" CREATED="1692048905403" MODIFIED="1692048927874">
<node TEXT=" let proxy = new Proxy(student,{&#xa;            get:function(target, property, receiver){&#xa;                //console.log(target, property, receiver)&#xa;            }&#xa;        });" ID="ID_156423084" CREATED="1692165657978" MODIFIED="1692165676074"/>
</node>
</node>
</node>
</node>
<node TEXT="代理访问" FOLDED="true" ID="ID_1500307735" CREATED="1692051966939" MODIFIED="1692051972148">
<node TEXT="访问时直接访问代理对象而不是源对象" ID="ID_1931719750" CREATED="1692051972371" MODIFIED="1692051985261"/>
<node TEXT="console.log(proxy.name)" ID="ID_363010413" CREATED="1692051999771" MODIFIED="1692052007164"/>
</node>
<node TEXT="代理解除" FOLDED="true" ID="ID_1820918096" CREATED="1692052817035" MODIFIED="1692052823117">
<node TEXT="const { proxy, revoke } = Proxy.revocable(target, handler); " ID="ID_467617415" CREATED="1692052823443" MODIFIED="1692052884477"/>
</node>
</node>
<node TEXT="Reflect反射对象" FOLDED="true" ID="ID_1376005554" CREATED="1692048716178" MODIFIED="1692048727797">
<node TEXT="可设置成员特性/对象成员" ID="ID_525956764" CREATED="1692053018660" MODIFIED="1692053148877">
<node TEXT="get：用于读取一个对象的属性值&#xa;set：用于设置一个对象的属性值&#xa;has：用于判断一个对象是否有某个属性&#xa;deleteProperty：用于删除一个对象的属性&#xa;apply：当前代理对象为函数，用于调用当前对象的方法&#xa;construct：用于通过构造函数创建一个新的对象实例&#xa;getOwnPropertyDescriptor：用于读取一个对象的自身属性描述对象&#xa;defineProperty： 用于为一个对象定义一个属性&#xa;getPrototypeOf：用于读取一个对象的原型对象&#xa;setPrototypeOf：用于设置一个对象的原型对象&#xa;isExtensible：用于判断一个对象是否可扩展&#xa;preventExtensions： 用于防止一个对象被扩展&#xa;ownKeys：用于读取一个对象的所有自身属性的键名" ID="ID_916236755" CREATED="1692048968483" MODIFIED="1692049014808"/>
<node TEXT="const handler = {&#xa; get() {&#xa; return Reflect.get(...arguments);&#xa; }&#xa; //简写get: Reflect.get&#xa;};" POSITION="bottom_or_right" ID="ID_594299798" CREATED="1692052122468" MODIFIED="1692052632342"/>
</node>
</node>
<node TEXT="使用场景" ID="ID_1510339041" CREATED="1692049067779" MODIFIED="1692049072348">
<node TEXT="const proxyFactory = (target, opts) =&gt; {&#xa;  return new Proxy(target, {&#xa;    set: (target, propertyKey, value, receiver) =&gt; {&#xa;      // console.log(target, propertyKey, value, receiver);&#xa;      console.log(&quot;执行了set&quot;);&#xa;      return Reflect.set(target, propertyKey, value);&#xa;    },&#xa;    get: (target, property, receiver) =&gt; {&#xa;      // console.log(target, property, receiver);&#xa;      console.log(&quot;执行了get&quot;);&#xa;      return Reflect.get(target, property, receiver);&#xa;    },&#xa;    has: (target, property) =&gt; {&#xa;      // console.log(target, property);&#xa;      console.log(&quot;执行了has&quot;);&#xa;      return Reflect.has(target, property);&#xa;    },&#xa;    deleteProperty: (target, property) =&gt; {&#xa;      // console.log(target, property);&#xa;      console.log(&quot;执行了deleteProperty&quot;);&#xa;      return Reflect.deleteProperty(target, property);&#xa;    },&#xa;    apply: (target, thisArg, argumentsList) =&gt; {&#xa;      // console.log(target, thisArg, argumentsList);&#xa;      console.log(&quot;执行了apply&quot;);&#xa;      return Reflect.apply(target, thisArg, argumentsList);&#xa;    },&#xa;    construct: (target, argumentsList, newTarget) =&gt; {&#xa;      // console.log(target, argumentsList, newTarget);&#xa;      console.log(&quot;执行了construct&quot;);&#xa;      return Reflect.construct(target, argumentsList, newTarget);&#xa;    },&#xa;    getOwnPropertyDescriptor: (target, property) =&gt; {&#xa;      // console.log(target, property);&#xa;      console.log(&quot;执行了getOwnPropertyDescriptor&quot;);&#xa;      return Reflect.getOwnPropertyDescriptor(target, property);&#xa;    },&#xa;    defineProperty: (target, property, descriptor) =&gt; {&#xa;      // console.log(target, property, descriptor);&#xa;      console.log(&quot;执行了defineProperty&quot;);&#xa;      return Reflect.defineProperty(target, property, descriptor);&#xa;    },&#xa;    getPrototypeOf: (target) =&gt; {&#xa;      // console.log(target);&#xa;      console.log(&quot;执行了getPrototypeOf&quot;);&#xa;      return Reflect.getPrototypeOf(target);&#xa;    },&#xa;    setPrototypeOf: (target, prototype) =&gt; {&#xa;      // console.log(target, prototype);&#xa;      console.log(&quot;执行了setPrototypeOf&quot;);&#xa;      return Reflect.setPrototypeOf(target, prototype);&#xa;    },&#xa;    isExtensible: (target) =&gt; {&#xa;      // console.log(target);&#xa;      console.log(&quot;执行了isExtensible&quot;);&#xa;      return Reflect.isExtensible(target);&#xa;    },&#xa;    preventExtensions: (target) =&gt; {&#xa;      // console.log(target);&#xa;      console.log(&quot;执行了preventExtensions&quot;);&#xa;      return Reflect.preventExtensions(target);&#xa;    },&#xa;    ownKeys: (target) =&gt; {&#xa;      // console.log(target);&#xa;      console.log(&quot;执行了ownKeys&quot;);&#xa;      return Reflect.ownKeys(target);&#xa;    },&#xa;    ...opts,&#xa;  });&#xa;};&#xa; &#xa;const obj = {&#xa;  name: &quot;张三&quot;,&#xa;  age: 20,&#xa;};&#xa;const fn = function () {&#xa;  return &quot;hello&quot;;&#xa;};&#xa;const __obj = proxyFactory(obj);&#xa;const __fn = proxyFactory(fn); // apply只有当当前代理对象为函数时才会执行&#xa;const init = () =&gt; {&#xa;  // set;&#xa;  __obj.name = &quot;李四&quot;;&#xa;  // get;&#xa;  __obj.name;&#xa;  // has;&#xa;  &quot;name&quot; in __obj;&#xa;  // deleteProperty;&#xa;  delete __obj.age;&#xa;  // apply;&#xa;  __fn();&#xa;  // construct;&#xa;  new __fn();&#xa;  // getOwnPropertyDescriptor;&#xa;  Object.getOwnPropertyDescriptor(__obj, &quot;name&quot;);&#xa;  // defineProperty;&#xa;  Object.defineProperty(__obj, &quot;name&quot;, {&#xa;    value: &quot;王五&quot;,&#xa;  });&#xa;  // getPrototypeOf;&#xa;  Object.getPrototypeOf(__obj);&#xa;  // setPrototypeOf;&#xa;  Object.setPrototypeOf(__obj, null);&#xa;  // isExtensible;&#xa;  Object.isExtensible(__obj);&#xa;  // preventExtensions;&#xa;  Object.preventExtensions(__obj);&#xa;  // ownKeys;&#xa;  Object.getOwnPropertyNames(__obj);&#xa;  console.log(__obj, obj);&#xa;};&#xa; &#xa;init();" ID="ID_117084599" CREATED="1692049072762" MODIFIED="1692049076641"/>
</node>
<node TEXT="es5实现反射与代理" FOLDED="true" ID="ID_1469861437" CREATED="1692049090762" MODIFIED="1692049101061">
<node TEXT="反射" FOLDED="true" ID="ID_75717916" CREATED="1692049102139" MODIFIED="1692049111052">
<node TEXT="var __Reflect = {&#xa;  set(target, prop, value) {&#xa;    target[prop] = value;&#xa;  },&#xa;  get(target, prop) {&#xa;    return target[prop];&#xa;  },&#xa;  defineProperty(target, property, descriptor) {&#xa;    return Object.defineProperty(target, property, descriptor);&#xa;  },&#xa;  deleteProperty(target, property) {&#xa;    return delete target[property];&#xa;  },&#xa;};" ID="ID_877454266" CREATED="1692049111242" MODIFIED="1692049113788"/>
</node>
<node TEXT="代理" FOLDED="true" ID="ID_1326055235" CREATED="1692049102699" MODIFIED="1692049120117">
<node TEXT="function __Proxy(target, handler) {&#xa;  var __target = {};&#xa;  this.target = target;&#xa;  this.handler = handler;&#xa;  this.init(__target);&#xa;  return __target;&#xa;}&#xa;__Proxy.prototype = {&#xa;  init(__target) {&#xa;    this.readWrite(__target);&#xa;    Object.__defineProperty = this.defineProperty.bind(this);&#xa;    Object.__delete = this.deleteProperty.bind(this);&#xa;  },&#xa;  readWrite(__target) {&#xa;    // 初始化读写函数&#xa;    var target = this.target;&#xa;    var handler = this.handler;&#xa;    for (const key in target) {&#xa;      Object.defineProperty(__target, key, {&#xa;        configurable: true,&#xa;        set(val) {&#xa;          // 新增/修改&#xa;          target[key] = val;&#xa;          return handler.set(target, key, val);&#xa;        },&#xa;        get() {&#xa;          // 读取&#xa;          return handler.get(target, key);&#xa;        },&#xa;      });&#xa;    }&#xa;  },&#xa;  defineProperty(target, property, descriptor) {&#xa;    // 定义/修改&#xa;    var __d = this.handler.defineProperty;&#xa;    var fn = typeof __d === &quot;function&quot; ? __d : __Reflect.defineProperty; // 如果钩子函数存在，则执行代理拦截函数&#xa;    return fn(target, property, descriptor);&#xa;  },&#xa;  deleteProperty(target, property) {&#xa;    // 删除&#xa;    var __delete = this.handler.deleteProperty;&#xa;    if (typeof __delete === &quot;function&quot;) {&#xa;      return __delete(target, property); // 如果钩子函数存在，则执行代理拦截函数&#xa;    }&#xa;    return __Reflect.deleteProperty(target, property);&#xa;  },&#xa;};" ID="ID_1380561195" CREATED="1692049120403" MODIFIED="1692049123035"/>
</node>
</node>
<node TEXT="优缺点" FOLDED="true" ID="ID_1540355885" CREATED="1692049140341" MODIFIED="1692165495857">
<node TEXT="缺点" ID="ID_149117551" CREATED="1692049148267" MODIFIED="1692049156868">
<node TEXT="1.代理和反射是ES6新增的两个对象，兼容性上会有一些折扣；&#xa;2.使用反射操作对象和直接操作对象还是有区别的，使用反射操作对象会有性能的损失；" ID="ID_1982099179" CREATED="1692049157226" MODIFIED="1692049186893"/>
</node>
<node TEXT="优点" ID="ID_1879859254" CREATED="1692049169107" MODIFIED="1692049172724">
<node TEXT="1.提高了对象的灵活性，监听对象及操作对象变得简易&#xa;2.拓展性变高了，可以应对更多针对对象的操作" ID="ID_1676972286" CREATED="1692049173218" MODIFIED="1692049201301"/>
</node>
</node>
</node>
<node TEXT="期约与异步函数" FOLDED="true" POSITION="bottom_or_right" ID="ID_1148936981" CREATED="1687644947192" MODIFIED="1687644966069">
<node TEXT="Promise对象" FOLDED="true" ID="ID_637414182" CREATED="1692137469702" MODIFIED="1692138656390">
<node TEXT="作用：解决回调函数多次嵌套（回调地狱）" ID="ID_715447472" CREATED="1692138668868" MODIFIED="1692138682461"/>
<node TEXT="实例化对象" ID="ID_338629753" CREATED="1692138685571" MODIFIED="1692138696854">
<node TEXT="new Promise(( resolve, reject ) =&gt;{})" ID="ID_1453371152" CREATED="1692138702035" MODIFIED="1692138711889">
<node TEXT="● Promise接受一个函数作为参数&#xa;● 在参数函数中有两个参数&#xa;  ○ resolve: 成功函数&#xa;  ○ reject: 失败函数" ID="ID_1389214889" CREATED="1692138712347" MODIFIED="1692138718793"/>
</node>
</node>
<node TEXT="成员属性" ID="ID_448154113" CREATED="1692138731339" MODIFIED="1692138743230">
<node TEXT="state: 状态" FOLDED="true" ID="ID_480918778" CREATED="1692138744036" MODIFIED="1692138844524"><richcontent TYPE="NOTE">
<html>
  <head>
    
  </head>
  <body>
    <p>
      Promise状态的改变是一次性的
    </p>
  </body>
</html>
</richcontent>
<node TEXT="第一种状态: pending（未开始）&#xa;第二种状态: fulfilled（成功）&#xa;第三种状态: rejected（失败）" ID="ID_344315808" CREATED="1692138759635" MODIFIED="1692138793441"/>
<node TEXT="resolve(): 调用函数, 使当前Promise对象的状态改成fulFilled" ID="ID_1286791438" CREATED="1692138814403" MODIFIED="1692138816570"/>
<node TEXT="reject(): 调用函数,使当前Promise对象状态改成rejected" ID="ID_1968215048" CREATED="1692138820355" MODIFIED="1692138821565"/>
</node>
<node TEXT="result: 结果" FOLDED="true" ID="ID_957952242" CREATED="1692138744835" MODIFIED="1692138753591">
<node TEXT=" // 通过调用 resolve、reject,传递参数,改变 当前Promise对象的结果" ID="ID_814240083" CREATED="1692138862364" MODIFIED="1692138887892"/>
<node TEXT="resolve(&quot;成功的结果&quot;);" ID="ID_1680689018" CREATED="1692138888061" MODIFIED="1692138888908"/>
<node TEXT="reject(&quot;失败的结果&quot;)" ID="ID_890927638" CREATED="1692138892956" MODIFIED="1692138894269"/>
</node>
</node>
<node TEXT="成员方法" FOLDED="true" ID="ID_1918216260" CREATED="1692138900538" MODIFIED="1692138908430">
<node TEXT="then方法" FOLDED="true" ID="ID_1630993247" CREATED="1692138908618" MODIFIED="1692138917055">
<node TEXT="const p = new Promise((resolve, reject) =&gt; {&#xa;  reject(&quot;失败的结果&quot;)&#xa;})&#xa;&#xa;// .then方法函数&#xa;// 参数&#xa;// 两个参数都是函数&#xa;// 返回值: 是一个Promise对象&#xa;p.then((value)=&gt;{&#xa;  // 当Promise的状态使fulfilled时执行&#xa;  console.log(&quot;成功的回调&quot;)&#xa;},(err)=&gt;{&#xa;  // 当Promise的状态时rejected时, 执行&#xa;  console.log(&quot;失败时调用&quot;)&#xa;})&#xa;console.log(p)" ID="ID_1673240513" CREATED="1692138961315" MODIFIED="1692139033994"/>
<node TEXT="注意" ID="ID_382989722" CREATED="1692139071115" MODIFIED="1692139074397">
<node TEXT="1.then方法返回一个新的Promise实例,状态时pending" ID="ID_1638533307" CREATED="1692139045915" MODIFIED="1692139213453"/>
<node TEXT="2.Promise的状态不改变,不会执行then里的方法" ID="ID_1655586886" CREATED="1692139057925" MODIFIED="1692139216612"/>
<node TEXT="3.在then方法中,通过return将返回的Promise实例改为fulfilled状态" ID="ID_607925548" CREATED="1692139064028" MODIFIED="1692139220246"/>
<node TEXT="4.在then方法中,出现代码错误,将返回的Promise实例改为rejected状态" ID="ID_1665178389" CREATED="1692139081475" MODIFIED="1692140880270"/>
</node>
</node>
<node TEXT="catch方法" ID="ID_609427778" CREATED="1692139102635" MODIFIED="1692139108165">
<node TEXT="const p = new Promise((resolve, reject) =&gt; {&#xa;  throw new Error(&quot;出错了&quot;);&#xa;})&#xa;&#xa;p.catch((reason =&gt; {&#xa;         console.log(&quot;失败&quot;, reason)&#xa;})&#xa;console.log(p);" ID="ID_924873239" CREATED="1692139108682" MODIFIED="1692139206036"/>
<node TEXT="注意" ID="ID_1437269879" CREATED="1692139175083" MODIFIED="1692139178851">
<node TEXT="1. 当Promise的状态改为rejcted执行" ID="ID_1872844375" CREATED="1692139181109" MODIFIED="1692139190488"/>
<node TEXT="2. 当Promise执行过程出现代码错误时执行" ID="ID_941648205" CREATED="1692139181110" MODIFIED="1692139192867"/>
</node>
</node>
<node TEXT="finally方法" ID="ID_838710163" CREATED="1692153523655" MODIFIED="1692153532687">
<node TEXT="无论如何都会执行" ID="ID_1479478665" CREATED="1692163194546" MODIFIED="1692163208060"/>
</node>
</node>
<node TEXT="Promise实现ajax操作" FOLDED="true" ID="ID_211776333" CREATED="1692139708691" MODIFIED="1692139723588">
<node TEXT="var getJSON = function(url) {&#xa;var promise = new Promise(function(resolve, reject){&#xa;var client = new XMLHttpRequest();&#xa;client.open(&quot;GET&quot;, url);&#xa;client.onreadystatechange = handler;&#xa;client.responseType = &quot;json&quot;;&#xa;client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);&#xa;client.send();&#xa;function handler() {&#xa;if (this.readyState !== 4) {&#xa;return;&#xa;}&#xa;if (this.status === 200) {&#xa;resolve(this.response);&#xa;} else {&#xa;reject(new Error(this.statusText));&#xa;}&#xa;};&#xa;});&#xa;return promise;&#xa;};&#xa;getJSON(&quot;/posts.json&quot;).then(function(json) {&#xa;console.log(&apos;Contents: &apos; + json);&#xa;}, function(error) {&#xa;console.error(&apos;出错了&apos;, error);&#xa;});" ID="ID_871663141" CREATED="1692139723995" MODIFIED="1692139732160"/>
</node>
<node TEXT="Promise中then的返回值" ID="ID_1803192875" CREATED="1692141293126" MODIFIED="1692141301233">
<node TEXT="1.如果p1的状态是pending，那么p2的状态也是pending。" ID="ID_895623427" CREATED="1692141307874" MODIFIED="1692141309272"/>
<node TEXT="2.如果p1的状态是resolved，then会去执行resolve()，那么p2的状态由resolve()的返回值决定。" ID="ID_1324051419" CREATED="1692141314305" MODIFIED="1692141320439">
<node TEXT="如果resolve()的返回值不是一个promise对象，那么p2的状态是resolved，且p2的值就是resolve()的return值。&#xa;如果resolve()的返回值是一个promise对象，那么p2的状态以及值由这个promise对象为准。&#xa;如果resolve()的返回值内部出现了错误（或者是用户抛出错误），那么p2的状态是rejected，且p2的值就是错误对象。" ID="ID_637331588" CREATED="1692141324994" MODIFIED="1692141343100"/>
</node>
<node TEXT="3.如果p1的状态是rejected，then会去执行reject()，那么p2的状态由reject()的返回值决定。" ID="ID_1667124613" CREATED="1692141348930" MODIFIED="1692141350869">
<node TEXT="如果reject()的返回值不是一个promise对象，那么p2的状态是resolved，且p2的值就是resolve()的return值。&#xa;如果reject()的返回值是一个promise对象，那么p2的状态以及值由这个promise对象为准。&#xa;如果resolve()的返回值内部出现了错误（或者是用户抛出错误），那么p2的状态是rejected，且p2的值就是错误对象。" ID="ID_1969628830" CREATED="1692141357362" MODIFIED="1692141364700"/>
</node>
<node TEXT="" ID="ID_1006127350" CREATED="1692164459348" MODIFIED="1692164459348">
<node TEXT="天堂.png" ID="ID_1279149211" CREATED="1692164460409" MODIFIED="1692164460424">
<hook URI="../../8.16/天堂.png" SIZE="0.5208333" NAME="ExternalObject"/>
</node>
</node>
</node>
</node>
<node TEXT="async和await" ID="ID_1865149570" CREATED="1692137470541" MODIFIED="1692139327986"/>
</node>
<node TEXT="迭代器与生成器" POSITION="bottom_or_right" ID="ID_1642130440" CREATED="1687644988120" MODIFIED="1687644994025"/>
<node TEXT="正则表达式" FOLDED="true" POSITION="top_or_left" ID="ID_245637922" CREATED="1691014412691" MODIFIED="1691014418287">
<node TEXT="作用" FOLDED="true" ID="ID_1672105527" CREATED="1691014439942" MODIFIED="1691015246193">
<node TEXT="查找、替换、验证和提取文本数据。" ID="ID_797559583" CREATED="1691015289974" MODIFIED="1691015291541"/>
</node>
<node TEXT="原子" FOLDED="true" ID="ID_1029054407" CREATED="1691014440718" MODIFIED="1691015350667">
<node TEXT="任意一个字符都是一个原子" ID="ID_1528745201" CREATED="1691015304559" MODIFIED="1691015464496"/>
<node TEXT="\d" ID="ID_1129486359" CREATED="1691015502937" MODIFIED="1691015524043">
<node TEXT="表示0-9任意一个字符" ID="ID_6779590" CREATED="1691015559961" MODIFIED="1691015576680"/>
</node>
<node TEXT="\D" ID="ID_1545966057" CREATED="1691015525532" MODIFIED="1691015530718">
<node TEXT="表示除了0-9任意一个字符" ID="ID_1090560439" CREATED="1691015585073" MODIFIED="1691015590505"/>
</node>
<node TEXT="\s" ID="ID_187129437" CREATED="1691015531824" MODIFIED="1691015541420">
<node TEXT="表示任意一个不可见字符：空格、锁进回车、换行等" ID="ID_1217147907" CREATED="1691015592148" MODIFIED="1691015627793"/>
</node>
<node TEXT="\S" ID="ID_1754993614" CREATED="1691015542267" MODIFIED="1691015547425">
<node TEXT="表示除了不可见字符外任意一个字符" ID="ID_690424029" CREATED="1691015633580" MODIFIED="1691015649361"/>
</node>
<node TEXT="\w" ID="ID_355164417" CREATED="1691015548557" MODIFIED="1691015552896">
<node TEXT="表示数字、字母、下划线中任意一个字符" ID="ID_1900230132" CREATED="1691015652806" MODIFIED="1691015667280"/>
</node>
<node TEXT="\W" ID="ID_553857894" CREATED="1691015553983" MODIFIED="1691015558677">
<node TEXT="表示除了数字、字母、下划线外任意一个字符" ID="ID_382056082" CREATED="1691015668422" MODIFIED="1691015679768"/>
</node>
<node TEXT="." ID="ID_1171288752" CREATED="1691016550173" MODIFIED="1691016554801">
<node TEXT="表示除了\n外任意一个字符，可以配合模式修正符s匹配任意字符" ID="ID_1956801506" CREATED="1691016555478" MODIFIED="1691016605567"/>
</node>
</node>
<node TEXT="元字符" FOLDED="true" ID="ID_238507374" CREATED="1691014441341" MODIFIED="1691015346407">
<node TEXT="数量限定" FOLDED="true" ID="ID_103690358" CREATED="1691015312743" MODIFIED="1691015720568">
<node TEXT="？" ID="ID_227478238" CREATED="1691015790612" MODIFIED="1691015809420">
<node TEXT="匹配前面的子表达式零次或一次。" ID="ID_1135724013" CREATED="1691015828624" MODIFIED="1691015830120"/>
</node>
<node TEXT="+" ID="ID_983932178" CREATED="1691015791145" MODIFIED="1691015811513">
<node TEXT="匹配前面的子表达式一次或多次" ID="ID_1059311291" CREATED="1691015850304" MODIFIED="1691015851885"/>
</node>
<node TEXT="*" ID="ID_1898926452" CREATED="1691015791669" MODIFIED="1691015813813">
<node TEXT="匹配前面的子表达式零次或多次。" ID="ID_1264567322" CREATED="1691015837736" MODIFIED="1691015844163"/>
</node>
<node TEXT="{m}" ID="ID_1697674873" CREATED="1691015792558" MODIFIED="1691015863701">
<node TEXT="匹配确定的 m次" ID="ID_317292593" CREATED="1691015871858" MODIFIED="1691015877050"/>
</node>
<node TEXT="{m,}" ID="ID_679960762" CREATED="1691015879649" MODIFIED="1691015885934">
<node TEXT="至少匹配m 次" ID="ID_216471646" CREATED="1691015898473" MODIFIED="1691015902048"/>
</node>
<node TEXT="{m,n}" ID="ID_1637324809" CREATED="1691015887236" MODIFIED="1691015891924">
<node TEXT="最少匹配 m 次且最多匹配 n 次" ID="ID_1670251536" CREATED="1691015910109" MODIFIED="1691015915847"/>
</node>
</node>
<node TEXT="字符集合" FOLDED="true" ID="ID_1467221765" CREATED="1691015940213" MODIFIED="1691015946874">
<node TEXT="[xyz]" ID="ID_279539223" CREATED="1691015956656" MODIFIED="1691015959446">
<node TEXT="字符集合，表示指定字符中x、y、z的一个" ID="ID_331808228" CREATED="1691015988718" MODIFIED="1691016019122"/>
</node>
<node TEXT="[^xyz]" ID="ID_1663952084" CREATED="1691015963846" MODIFIED="1691015968025">
<node TEXT="字符集合，表示指定字符外的任意一个字符" ID="ID_249574620" CREATED="1691016005165" MODIFIED="1691016049538"/>
</node>
<node TEXT="[a-z]" ID="ID_1371118609" CREATED="1691015972411" MODIFIED="1691015978344">
<node TEXT="字符范围，表示字符a-z中的任意一个" ID="ID_66289589" CREATED="1691016055362" MODIFIED="1691016079053"/>
</node>
<node TEXT="[^a-z]" ID="ID_1051520071" CREATED="1691015982274" MODIFIED="1691015983633">
<node TEXT="字符范围，表示字符a-z外的任意一个字符" ID="ID_1194270380" CREATED="1691016083123" MODIFIED="1691016091522"/>
</node>
</node>
<node TEXT="边界限定" FOLDED="true" ID="ID_660353535" CREATED="1691016125942" MODIFIED="1691016133639">
<node TEXT="\b" ID="ID_467576952" CREATED="1691016176960" MODIFIED="1691016180099">
<node TEXT="匹配一个单词边界" ID="ID_455694752" CREATED="1691016211442" MODIFIED="1691016213080"/>
</node>
<node TEXT="\B" ID="ID_160705653" CREATED="1691016181167" MODIFIED="1691016189933">
<node TEXT="匹配非单词边界" ID="ID_1847845994" CREATED="1691016219496" MODIFIED="1691016221030"/>
</node>
<node TEXT="^" ID="ID_886674261" CREATED="1691016190912" MODIFIED="1691016196603">
<node TEXT="匹配输入字符串的开始位置" ID="ID_1024918610" CREATED="1691016238249" MODIFIED="1691016241706"/>
</node>
<node TEXT="$" ID="ID_333287004" CREATED="1691016197601" MODIFIED="1691016201213">
<node TEXT="匹配输入字符串的结束位置" ID="ID_120647883" CREATED="1691016249341" MODIFIED="1691016254553"/>
</node>
</node>
<node TEXT="优先级及存储" FOLDED="true" ID="ID_370708303" CREATED="1691016284862" MODIFIED="1691016314355">
<node TEXT="(pattern)" ID="ID_1863345987" CREATED="1691016315080" MODIFIED="1691016316687">
<node TEXT="匹配 pattern 并获取这一匹配&#xa;在JScript 中则使用 $0…$9 属性" ID="ID_843675304" CREATED="1691016321812" MODIFIED="1691016381198"/>
</node>
<node TEXT="(?:pattern)" ID="ID_67131577" CREATED="1691016328343" MODIFIED="1691016332579">
<node TEXT="匹配 pattern 但不存储取匹配结果" ID="ID_549676773" CREATED="1691016342567" MODIFIED="1691016355286"/>
</node>
</node>
<node TEXT="逻辑运算" FOLDED="true" ID="ID_298449776" CREATED="1691016415713" MODIFIED="1691016419883">
<node TEXT="x｜y" ID="ID_1793073532" CREATED="1691016420262" MODIFIED="1691016454307">
<node TEXT="匹配 x 或 y" ID="ID_108169261" CREATED="1691016441724" MODIFIED="1691016448372"/>
</node>
</node>
</node>
<node TEXT="模式修正符" FOLDED="true" ID="ID_888888181" CREATED="1691014442364" MODIFIED="1691015335554">
<node TEXT="i" ID="ID_1582421971" CREATED="1691015389470" MODIFIED="1691015391829">
<node TEXT="&#x9;ignore - 不区分大小写" ID="ID_1206167900" CREATED="1691015392816" MODIFIED="1691015394258"/>
</node>
<node TEXT="g" ID="ID_1970382612" CREATED="1691015400214" MODIFIED="1691015402370">
<node TEXT="global - 全局匹配" ID="ID_1541246591" CREATED="1691015403007" MODIFIED="1691015404473"/>
</node>
<node TEXT="m" ID="ID_1555337864" CREATED="1691015411680" MODIFIED="1691015415158">
<node TEXT="multi line - 多行匹配" ID="ID_1496918151" CREATED="1691015415694" MODIFIED="1691015417199"/>
</node>
<node TEXT="s" ID="ID_1239142950" CREATED="1691015440060" MODIFIED="1691015442088">
<node TEXT="特殊字符圆点 . 中包含换行符 \n" ID="ID_1865694527" CREATED="1691015442855" MODIFIED="1691015444440"/>
</node>
<node TEXT="d" ID="ID_1681553644" CREATED="1691019554603" MODIFIED="1691019556858">
<node TEXT="正则匹配后获取开始结束索引" ID="ID_1966907750" CREATED="1691019556864" MODIFIED="1691019572104">
<node TEXT="let [s,e] =  reg.exec(string).indices[0]" ID="ID_781055894" CREATED="1691019627645" MODIFIED="1691019666071">
<node TEXT="" ID="ID_1848345704" CREATED="1691019638579" MODIFIED="1691019638579"/>
</node>
</node>
</node>
</node>
<node TEXT="正则函数" ID="ID_1818708276" CREATED="1691015352155" MODIFIED="1691015356728"/>
<node TEXT="字符转义" FOLDED="true" ID="ID_656348864" CREATED="1691016822538" MODIFIED="1691016829900">
<node TEXT="在正则规则中的字符，如果要匹配必须进行\转义操作" ID="ID_679222218" CREATED="1691016835387" MODIFIED="1691016872620"/>
</node>
</node>
</node>
</map>
